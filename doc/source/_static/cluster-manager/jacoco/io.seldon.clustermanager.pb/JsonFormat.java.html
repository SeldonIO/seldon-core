<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonFormat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">seldon-cluster-manager</a> &gt; <a href="index.source.html" class="el_package">io.seldon.clustermanager.pb</a> &gt; <span class="el_source">JsonFormat.java</span></div><h1>JsonFormat.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2017 Seldon Technologies Ltd (http://www.seldon.io/)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package io.seldon.clustermanager.pb;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.text.ParseException;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Logger;

import com.google.common.io.BaseEncoding;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.google.gson.stream.JsonReader;
import com.google.protobuf.Any;
import com.google.protobuf.BoolValue;
import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.Descriptors.Descriptor;
import com.google.protobuf.Descriptors.EnumDescriptor;
import com.google.protobuf.Descriptors.EnumValueDescriptor;
import com.google.protobuf.Descriptors.FieldDescriptor;
import com.google.protobuf.Descriptors.FileDescriptor;
import com.google.protobuf.Descriptors.OneofDescriptor;
import com.google.protobuf.DoubleValue;
import com.google.protobuf.Duration;
import com.google.protobuf.DynamicMessage;
import com.google.protobuf.FieldMask;
import com.google.protobuf.FloatValue;
import com.google.protobuf.Int32Value;
import com.google.protobuf.Int64Value;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.ListValue;
import com.google.protobuf.Message;
import com.google.protobuf.MessageOrBuilder;
import com.google.protobuf.NullValue;
import com.google.protobuf.StringValue;
import com.google.protobuf.Struct;
import com.google.protobuf.Timestamp;
import com.google.protobuf.UInt32Value;
import com.google.protobuf.UInt64Value;
import com.google.protobuf.Value;
import com.google.protobuf.util.Durations;
import com.google.protobuf.util.FieldMaskUtil;
import com.google.protobuf.util.Timestamps;

/**
 * Utility classes to convert protobuf messages to/from JSON format. The JSON
 * format follows Proto3 JSON specification and only proto3 features are
 * supported. Proto2 only features (e.g., extensions and unknown fields) will
 * be discarded in the conversion. That is, when converting proto2 messages
 * to JSON format, extensions and unknown fields will be treated as if they
 * do not exist. This applies to proto2 messages embedded in proto3 messages
 * as well.
 */
public class JsonFormat {
<span class="fc" id="L85">  private static final Logger logger = Logger.getLogger(JsonFormat.class.getName());</span>

  public interface TypeConverter {
	  public String convert(MessageOrBuilder message) throws IOException;
  }
  
  public interface TypeParser {
      void merge(JsonElement json, Message.Builder builder)
          throws InvalidProtocolBufferException;
    }
  
  private JsonFormat() {}

  /**
   * Creates a {@link Printer} with default configurations.
   */
  public static Printer printer() {
<span class="fc" id="L102">    return new Printer(TypeRegistry.getEmptyTypeRegistry(), false, false, false,new HashMap&lt;String,TypeConverter&gt;());</span>
  }

  /**
   * A Printer converts protobuf message to JSON format.
   */
  public static class Printer {
    private final TypeRegistry registry;
    private final boolean includingDefaultValueFields;
    private final boolean preservingProtoFieldNames;
    private final boolean omittingInsignificantWhitespace;
    private final Map&lt;String,TypeConverter&gt; customTypeConverters;

    private Printer(
        TypeRegistry registry,
        boolean includingDefaultValueFields,
        boolean preservingProtoFieldNames,
        boolean omittingInsignificantWhitespace,
<span class="fc" id="L120">        Map&lt;String,TypeConverter&gt; customTypeConverters) {</span>
<span class="fc" id="L121">      this.registry = registry;</span>
<span class="fc" id="L122">      this.includingDefaultValueFields = includingDefaultValueFields;</span>
<span class="fc" id="L123">      this.preservingProtoFieldNames = preservingProtoFieldNames;</span>
<span class="fc" id="L124">      this.omittingInsignificantWhitespace = omittingInsignificantWhitespace;</span>
<span class="fc" id="L125">      this.customTypeConverters = customTypeConverters;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Adds a custom TypeConverter
     */
    public Printer usingTypeConverter(String type,TypeConverter converter)
    {
<span class="fc" id="L133">    	this.customTypeConverters.put(type,converter);</span>
<span class="fc" id="L134">    	return new Printer(</span>
    	          registry,
    	          includingDefaultValueFields,
    	          preservingProtoFieldNames,
    	          omittingInsignificantWhitespace,
    	          customTypeConverters);
    }
    
    /**
     * Creates a new {@link Printer} using the given registry. The new Printer
     * clones all other configurations from the current {@link Printer}.
     *
     * @throws IllegalArgumentException if a registry is already set.
     */
    public Printer usingTypeRegistry(TypeRegistry registry) {
<span class="nc bnc" id="L149" title="All 2 branches missed.">      if (this.registry != TypeRegistry.getEmptyTypeRegistry()) {</span>
<span class="nc" id="L150">        throw new IllegalArgumentException(&quot;Only one registry is allowed.&quot;);</span>
      }
<span class="nc" id="L152">      return new Printer(</span>
          registry,
          includingDefaultValueFields,
          preservingProtoFieldNames,
          omittingInsignificantWhitespace,
          customTypeConverters);
    }

    /**
     * Creates a new {@link Printer} that will also print fields set to their
     * defaults. Empty repeated fields and map fields will be printed as well.
     * The new Printer clones all other configurations from the current
     * {@link Printer}.
     */
    public Printer includingDefaultValueFields() {
<span class="nc" id="L167">      return new Printer(</span>
          registry, true, preservingProtoFieldNames, omittingInsignificantWhitespace,customTypeConverters);
    }

    /**
     * Creates a new {@link Printer} that is configured to use the original proto
     * field names as defined in the .proto file rather than converting them to
     * lowerCamelCase. The new Printer clones all other configurations from the
     * current {@link Printer}.
     */
    public Printer preservingProtoFieldNames() {
<span class="fc" id="L178">      return new Printer(</span>
          registry, includingDefaultValueFields, true, omittingInsignificantWhitespace,customTypeConverters);
    }


    /**
     * Create a new  {@link Printer}  that will omit all insignificant whitespace
     * in the JSON output. This new Printer clones all other configurations from the
     * current Printer. Insignificant whitespace is defined by the JSON spec as whitespace
     * that appear between JSON structural elements:
     * &lt;pre&gt;
     * ws = *(
     * %x20 /              ; Space
     * %x09 /              ; Horizontal tab
     * %x0A /              ; Line feed or New line
     * %x0D )              ; Carriage return
     * &lt;/pre&gt;
     * See &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;https://tools.ietf.org/html/rfc7159&lt;/a&gt;
     * current {@link Printer}.
     */
    public Printer omittingInsignificantWhitespace() {
<span class="fc" id="L199">      return new Printer(registry, includingDefaultValueFields, preservingProtoFieldNames, true,customTypeConverters);</span>
    }

    /**
     * Converts a protobuf message to JSON format.
     *
     * @throws InvalidProtocolBufferException if the message contains Any types
     *         that can't be resolved.
     * @throws IOException if writing to the output fails.
     */
    public void appendTo(MessageOrBuilder message, Appendable output) throws IOException {
      // TODO(xiaofeng): Investigate the allocation overhead and optimize for
      // mobile.
<span class="fc" id="L212">      new PrinterImpl(</span>
              registry,
              includingDefaultValueFields,
              preservingProtoFieldNames,
              output,
              omittingInsignificantWhitespace,
              customTypeConverters)
<span class="fc" id="L219">          .print(message);</span>
<span class="fc" id="L220">    }</span>

    /**
     * Converts a protobuf message to JSON format. Throws exceptions if there
     * are unknown Any types in the message.
     */
    public String print(MessageOrBuilder message) throws InvalidProtocolBufferException {
      try {
<span class="fc" id="L228">        StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L229">        appendTo(message, builder);</span>
<span class="fc" id="L230">        return builder.toString();</span>
<span class="nc" id="L231">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L232">        throw e;</span>
<span class="nc" id="L233">      } catch (IOException e) {</span>
        // Unexpected IOException.
<span class="nc" id="L235">        throw new IllegalStateException(e);</span>
      }
    }
  }

  /**
   * Creates a {@link Parser} with default configuration.
   */
  public static Parser parser() {
<span class="fc" id="L244">    return new Parser(TypeRegistry.getEmptyTypeRegistry(), false, Parser.DEFAULT_RECURSION_LIMIT,new HashMap&lt;String,TypeParser&gt;());</span>
  }

  /**
   * A Parser parses JSON to protobuf message.
   */
  public static class Parser {
    private final TypeRegistry registry;
    private final Map&lt;String,TypeParser&gt; typeParsers;
    private final boolean ignoringUnknownFields;
    private final int recursionLimit;

    // The default parsing recursion limit is aligned with the proto binary parser.
    private static final int DEFAULT_RECURSION_LIMIT = 100;

<span class="fc" id="L259">    private Parser(TypeRegistry registry, boolean ignoreUnknownFields, int recursionLimit,Map&lt;String,TypeParser&gt; typeParsers) {</span>
<span class="fc" id="L260">      this.registry = registry;</span>
<span class="fc" id="L261">      this.ignoringUnknownFields = ignoreUnknownFields;</span>
<span class="fc" id="L262">      this.recursionLimit = recursionLimit;</span>
<span class="fc" id="L263">      this.typeParsers = typeParsers;</span>
<span class="fc" id="L264">    }</span>

    /**
     * Adds a {@link TypeParser} for the given type
     */
    public Parser usingTypeParser(String type,TypeParser parser)
    {
<span class="fc" id="L271">    	this.typeParsers.put(type, parser);</span>
<span class="fc" id="L272">    	return new Parser(registry, ignoringUnknownFields, recursionLimit,typeParsers);</span>
    }
    
    /**
     * Creates a new {@link Parser} using the given registry. The new Parser
     * clones all other configurations from this Parser.
     *
     * @throws IllegalArgumentException if a registry is already set.
     */
    public Parser usingTypeRegistry(TypeRegistry registry) {
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (this.registry != TypeRegistry.getEmptyTypeRegistry()) {</span>
<span class="nc" id="L283">        throw new IllegalArgumentException(&quot;Only one registry is allowed.&quot;);</span>
      }
<span class="nc" id="L285">      return new Parser(registry, ignoringUnknownFields, recursionLimit,typeParsers);</span>
    }

    /**
     * Creates a new {@link Parser} configured to not throw an exception when an unknown field is
     * encountered. The new Parser clones all other configurations from this Parser.
     */
    public Parser ignoringUnknownFields() {
<span class="nc" id="L293">      return new Parser(this.registry, true, recursionLimit,typeParsers);</span>
    }

    /**
     * Parses from JSON into a protobuf message.
     *
     * @throws InvalidProtocolBufferException if the input is not valid JSON
     *         format or there are unknown fields in the input.
     */
    public void merge(String json, Message.Builder builder) throws InvalidProtocolBufferException {
      // TODO(xiaofeng): Investigate the allocation overhead and optimize for
      // mobile.
<span class="fc" id="L305">      new ParserImpl(registry, ignoringUnknownFields, recursionLimit,typeParsers).merge(json, builder);</span>
<span class="fc" id="L306">    }</span>

    /**
     * Parses from JSON into a protobuf message.
     *
     * @throws InvalidProtocolBufferException if the input is not valid JSON
     *         format or there are unknown fields in the input.
     * @throws IOException if reading from the input throws.
     */
    public void merge(Reader json, Message.Builder builder) throws IOException {
      // TODO(xiaofeng): Investigate the allocation overhead and optimize for
      // mobile.
<span class="nc" id="L318">      new ParserImpl(registry, ignoringUnknownFields, recursionLimit,typeParsers).merge(json, builder);</span>
<span class="nc" id="L319">    }</span>

    // For testing only.
    Parser usingRecursionLimit(int recursionLimit) {
<span class="nc" id="L323">      return new Parser(registry, ignoringUnknownFields, recursionLimit,typeParsers);</span>
    }
  }

  /**
   * A TypeRegistry is used to resolve Any messages in the JSON conversion.
   * You must provide a TypeRegistry containing all message types used in
   * Any message fields, or the JSON conversion will fail because data
   * in Any message fields is unrecognizable. You don't need to supply a
   * TypeRegistry if you don't use Any message fields.
   */
  public static class TypeRegistry {
    private static class EmptyTypeRegistryHolder {
<span class="fc" id="L336">      private static final TypeRegistry EMPTY =</span>
<span class="fc" id="L337">          new TypeRegistry(Collections.&lt;String, Descriptor&gt;emptyMap());</span>
    }

    public static TypeRegistry getEmptyTypeRegistry() {
<span class="fc" id="L341">      return EmptyTypeRegistryHolder.EMPTY;</span>
    }

    public static Builder newBuilder() {
<span class="nc" id="L345">      return new Builder();</span>
    }

    /**
     * Find a type by its full name. Returns null if it cannot be found in
     * this {@link TypeRegistry}.
     */
    public Descriptor find(String name) {
<span class="nc" id="L353">      return types.get(name);</span>
    }

    private final Map&lt;String, Descriptor&gt; types;

<span class="fc" id="L358">    private TypeRegistry(Map&lt;String, Descriptor&gt; types) {</span>
<span class="fc" id="L359">      this.types = types;</span>
<span class="fc" id="L360">    }</span>

    /**
     * A Builder is used to build {@link TypeRegistry}.
     */
    public static class Builder {
<span class="nc" id="L366">      private Builder() {}</span>

      /**
       * Adds a message type and all types defined in the same .proto file as
       * well as all transitively imported .proto files to this {@link Builder}.
       */
      public Builder add(Descriptor messageType) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (types == null) {</span>
<span class="nc" id="L374">          throw new IllegalStateException(&quot;A TypeRegistry.Builer can only be used once.&quot;);</span>
        }
<span class="nc" id="L376">        addFile(messageType.getFile());</span>
<span class="nc" id="L377">        return this;</span>
      }

      /**
       * Adds message types and all types defined in the same .proto file as
       * well as all transitively imported .proto files to this {@link Builder}.
       */
      public Builder add(Iterable&lt;Descriptor&gt; messageTypes) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (types == null) {</span>
<span class="nc" id="L386">          throw new IllegalStateException(&quot;A TypeRegistry.Builer can only be used once.&quot;);</span>
        }
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (Descriptor type : messageTypes) {</span>
<span class="nc" id="L389">          addFile(type.getFile());</span>
<span class="nc" id="L390">        }</span>
<span class="nc" id="L391">        return this;</span>
      }

      /**
       * Builds a {@link TypeRegistry}. This method can only be called once for
       * one Builder.
       */
      public TypeRegistry build() {
<span class="nc" id="L399">        TypeRegistry result = new TypeRegistry(types);</span>
        // Make sure the built {@link TypeRegistry} is immutable.
<span class="nc" id="L401">        types = null;</span>
<span class="nc" id="L402">        return result;</span>
      }

      private void addFile(FileDescriptor file) {
        // Skip the file if it's already added.
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (!files.add(file.getFullName())) {</span>
<span class="nc" id="L408">          return;</span>
        }
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (FileDescriptor dependency : file.getDependencies()) {</span>
<span class="nc" id="L411">          addFile(dependency);</span>
<span class="nc" id="L412">        }</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        for (Descriptor message : file.getMessageTypes()) {</span>
<span class="nc" id="L414">          addMessage(message);</span>
<span class="nc" id="L415">        }</span>
<span class="nc" id="L416">      }</span>

      private void addMessage(Descriptor message) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (Descriptor nestedType : message.getNestedTypes()) {</span>
<span class="nc" id="L420">          addMessage(nestedType);</span>
<span class="nc" id="L421">        }</span>

<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (types.containsKey(message.getFullName())) {</span>
<span class="nc" id="L424">          logger.warning(&quot;Type &quot; + message.getFullName() + &quot; is added multiple times.&quot;);</span>
<span class="nc" id="L425">          return;</span>
        }

<span class="nc" id="L428">        types.put(message.getFullName(), message);</span>
<span class="nc" id="L429">      }</span>

<span class="nc" id="L431">      private final Set&lt;String&gt; files = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L432">      private Map&lt;String, Descriptor&gt; types = new HashMap&lt;String, Descriptor&gt;();</span>
    }
  }

  /**
   * An interface for json formatting that can be used in
   * combination with the omittingInsignificantWhitespace() method
   */
  interface TextGenerator {
    void indent();

    void outdent();

    void print(final CharSequence text) throws IOException;
  }

  /**
   * Format the json without indentation
   */
  private static final class CompactTextGenerator implements TextGenerator {
    private final Appendable output;

<span class="fc" id="L454">    private CompactTextGenerator(final Appendable output) {</span>
<span class="fc" id="L455">      this.output = output;</span>
<span class="fc" id="L456">    }</span>

    /**
     * ignored by compact printer
     */
<span class="fc" id="L461">    public void indent() {}</span>

    /**
     * ignored by compact printer
     */
<span class="fc" id="L466">    public void outdent() {}</span>

    /**
     * Print text to the output stream.
     */
    public void print(final CharSequence text) throws IOException {
<span class="fc" id="L472">      output.append(text);</span>
<span class="fc" id="L473">    }</span>
  }
  /**
   * A TextGenerator adds indentation when writing formatted text.
   */
  private static final class PrettyTextGenerator implements TextGenerator {
    private final Appendable output;
<span class="fc" id="L480">    private final StringBuilder indent = new StringBuilder();</span>
<span class="fc" id="L481">    private boolean atStartOfLine = true;</span>

<span class="fc" id="L483">    private PrettyTextGenerator(final Appendable output) {</span>
<span class="fc" id="L484">      this.output = output;</span>
<span class="fc" id="L485">    }</span>

    /**
     * Indent text by two spaces.  After calling Indent(), two spaces will be
     * inserted at the beginning of each line of text.  Indent() may be called
     * multiple times to produce deeper indents.
     */
    public void indent() {
<span class="fc" id="L493">      indent.append(&quot;  &quot;);</span>
<span class="fc" id="L494">    }</span>

    /**
     * Reduces the current indent level by two spaces, or crashes if the indent
     * level is zero.
     */
    public void outdent() {
<span class="fc" id="L501">      final int length = indent.length();</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">      if (length &lt; 2) {</span>
<span class="nc" id="L503">        throw new IllegalArgumentException(&quot; Outdent() without matching Indent().&quot;);</span>
      }
<span class="fc" id="L505">      indent.delete(length - 2, length);</span>
<span class="fc" id="L506">    }</span>

    /**
     * Print text to the output stream.
     */
    public void print(final CharSequence text) throws IOException {
<span class="fc" id="L512">      final int size = text.length();</span>
<span class="fc" id="L513">      int pos = 0;</span>

<span class="fc bfc" id="L515" title="All 2 branches covered.">      for (int i = 0; i &lt; size; i++) {</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (text.charAt(i) == '\n') {</span>
<span class="fc" id="L517">          write(text.subSequence(pos, i + 1));</span>
<span class="fc" id="L518">          pos = i + 1;</span>
<span class="fc" id="L519">          atStartOfLine = true;</span>
        }
      }
<span class="fc" id="L522">      write(text.subSequence(pos, size));</span>
<span class="fc" id="L523">    }</span>

    private void write(final CharSequence data) throws IOException {
<span class="fc bfc" id="L526" title="All 2 branches covered.">      if (data.length() == 0) {</span>
<span class="fc" id="L527">        return;</span>
      }
<span class="fc bfc" id="L529" title="All 2 branches covered.">      if (atStartOfLine) {</span>
<span class="fc" id="L530">        atStartOfLine = false;</span>
<span class="fc" id="L531">        output.append(indent);</span>
      }
<span class="fc" id="L533">      output.append(data);</span>
<span class="fc" id="L534">    }</span>
  }

  /**
   * A Printer converts protobuf messages to JSON format.
   */
  private static final class PrinterImpl {
    private final TypeRegistry registry;
    private final Map&lt;String,TypeConverter&gt; typeConverters;
    private final boolean includingDefaultValueFields;
    private final boolean preservingProtoFieldNames;
    private final TextGenerator generator;
    // We use Gson to help handle string escapes.
    private final Gson gson;
    private final CharSequence blankOrSpace;
    private final CharSequence blankOrNewLine;

    private static class GsonHolder {
<span class="fc" id="L552">      private static final Gson DEFAULT_GSON = new GsonBuilder().disableHtmlEscaping().create();</span>
    }

    PrinterImpl(
        TypeRegistry registry,
        boolean includingDefaultValueFields,
        boolean preservingProtoFieldNames,
        Appendable jsonOutput,
        boolean omittingInsignificantWhitespace,
<span class="fc" id="L561">        Map&lt;String,TypeConverter&gt; typeConverters) {</span>
<span class="fc" id="L562">      this.registry = registry;</span>
<span class="fc" id="L563">      this.includingDefaultValueFields = includingDefaultValueFields;</span>
<span class="fc" id="L564">      this.preservingProtoFieldNames = preservingProtoFieldNames;</span>
<span class="fc" id="L565">      this.typeConverters = typeConverters;</span>
<span class="fc" id="L566">      this.gson = GsonHolder.DEFAULT_GSON;</span>
      // json format related properties, determined by printerType
<span class="fc bfc" id="L568" title="All 2 branches covered.">      if (omittingInsignificantWhitespace) {</span>
<span class="fc" id="L569">        this.generator = new CompactTextGenerator(jsonOutput);</span>
<span class="fc" id="L570">        this.blankOrSpace = &quot;&quot;;</span>
<span class="fc" id="L571">        this.blankOrNewLine = &quot;&quot;;</span>
      } else {
<span class="fc" id="L573">        this.generator = new PrettyTextGenerator(jsonOutput);</span>
<span class="fc" id="L574">        this.blankOrSpace = &quot; &quot;;</span>
<span class="fc" id="L575">        this.blankOrNewLine = &quot;\n&quot;;</span>
      }
<span class="fc" id="L577">    }</span>

    void print(MessageOrBuilder message) throws IOException {
<span class="fc bfc" id="L580" title="All 2 branches covered.">        if (typeConverters.containsKey(message.getDescriptorForType().getFullName()))</span>
        {
<span class="fc" id="L582">            String msg = typeConverters.get(message.getDescriptorForType().getFullName()).convert(message);</span>
<span class="fc" id="L583">            generator.print(msg);</span>
<span class="fc" id="L584">            return;  </span>
        } 
            
<span class="fc" id="L587">        WellKnownTypePrinter specialPrinter =</span>
<span class="fc" id="L588">          wellKnownTypePrinters.get(message.getDescriptorForType().getFullName());</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (specialPrinter != null) {</span>
<span class="nc" id="L590">            specialPrinter.print(this, message);</span>
<span class="nc" id="L591">            return;</span>
        }
      
<span class="fc" id="L594">        print(message, null);</span>
<span class="fc" id="L595">    }</span>

    private interface WellKnownTypePrinter {
      void print(PrinterImpl printer, MessageOrBuilder message) throws IOException;
    }

<span class="fc" id="L601">    private static final Map&lt;String, WellKnownTypePrinter&gt; wellKnownTypePrinters =</span>
<span class="fc" id="L602">        buildWellKnownTypePrinters();</span>

    private static Map&lt;String, WellKnownTypePrinter&gt; buildWellKnownTypePrinters() {
<span class="fc" id="L605">      Map&lt;String, WellKnownTypePrinter&gt; printers = new HashMap&lt;String, WellKnownTypePrinter&gt;();</span>
      // Special-case Any.
<span class="fc" id="L607">      printers.put(</span>
<span class="fc" id="L608">          Any.getDescriptor().getFullName(),</span>
<span class="fc" id="L609">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L612">              printer.printAny(message);</span>
<span class="nc" id="L613">            }</span>
          });
      // Special-case wrapper types.
<span class="fc" id="L616">      WellKnownTypePrinter wrappersPrinter =</span>
<span class="fc" id="L617">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L620">              printer.printWrapper(message);</span>
<span class="nc" id="L621">            }</span>
          };
<span class="fc" id="L623">      printers.put(BoolValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L624">      printers.put(Int32Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L625">      printers.put(UInt32Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L626">      printers.put(Int64Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L627">      printers.put(UInt64Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L628">      printers.put(StringValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L629">      printers.put(BytesValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L630">      printers.put(FloatValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L631">      printers.put(DoubleValue.getDescriptor().getFullName(), wrappersPrinter);</span>
      // Special-case Timestamp.
<span class="fc" id="L633">      printers.put(</span>
<span class="fc" id="L634">          Timestamp.getDescriptor().getFullName(),</span>
<span class="fc" id="L635">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L638">              printer.printTimestamp(message);</span>
<span class="nc" id="L639">            }</span>
          });
      // Special-case Duration.
<span class="fc" id="L642">      printers.put(</span>
<span class="fc" id="L643">          Duration.getDescriptor().getFullName(),</span>
<span class="fc" id="L644">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L647">              printer.printDuration(message);</span>
<span class="nc" id="L648">            }</span>
          });
      // Special-case FieldMask.
<span class="fc" id="L651">      printers.put(</span>
<span class="fc" id="L652">          FieldMask.getDescriptor().getFullName(),</span>
<span class="fc" id="L653">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L656">              printer.printFieldMask(message);</span>
<span class="nc" id="L657">            }</span>
          });
      // Special-case Struct.
<span class="fc" id="L660">      printers.put(</span>
<span class="fc" id="L661">          Struct.getDescriptor().getFullName(),</span>
<span class="fc" id="L662">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L665">              printer.printStruct(message);</span>
<span class="nc" id="L666">            }</span>
          });
      // Special-case Value.
<span class="fc" id="L669">      printers.put(</span>
<span class="fc" id="L670">          Value.getDescriptor().getFullName(),</span>
<span class="fc" id="L671">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L674">              printer.printValue(message);</span>
<span class="nc" id="L675">            }</span>
          });
      // Special-case ListValue.
<span class="fc" id="L678">      printers.put(</span>
<span class="fc" id="L679">          ListValue.getDescriptor().getFullName(),</span>
<span class="fc" id="L680">          new WellKnownTypePrinter() {</span>
            @Override
            public void print(PrinterImpl printer, MessageOrBuilder message) throws IOException {
<span class="nc" id="L683">              printer.printListValue(message);</span>
<span class="nc" id="L684">            }</span>
          });
<span class="fc" id="L686">      return printers;</span>
    }

    /** Prints google.protobuf.Any */
    private void printAny(MessageOrBuilder message) throws IOException {
<span class="nc bnc" id="L691" title="All 2 branches missed.">      if (Any.getDefaultInstance().equals(message)) {</span>
<span class="nc" id="L692">        generator.print(&quot;{}&quot;);</span>
<span class="nc" id="L693">        return;</span>
      }
<span class="nc" id="L695">      Descriptor descriptor = message.getDescriptorForType();</span>
<span class="nc" id="L696">      FieldDescriptor typeUrlField = descriptor.findFieldByName(&quot;type_url&quot;);</span>
<span class="nc" id="L697">      FieldDescriptor valueField = descriptor.findFieldByName(&quot;value&quot;);</span>
      // Validates type of the message. Note that we can't just cast the message
      // to com.google.protobuf.Any because it might be a DynamicMessage.
<span class="nc bnc" id="L700" title="All 4 branches missed.">      if (typeUrlField == null</span>
          || valueField == null
<span class="nc bnc" id="L702" title="All 2 branches missed.">          || typeUrlField.getType() != FieldDescriptor.Type.STRING</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">          || valueField.getType() != FieldDescriptor.Type.BYTES) {</span>
<span class="nc" id="L704">        throw new InvalidProtocolBufferException(&quot;Invalid Any type.&quot;);</span>
      }
<span class="nc" id="L706">      String typeUrl = (String) message.getField(typeUrlField);</span>
<span class="nc" id="L707">      String typeName = getTypeName(typeUrl);</span>
<span class="nc" id="L708">      Descriptor type = registry.find(typeName);</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">      if (type == null) {</span>
<span class="nc" id="L710">        throw new InvalidProtocolBufferException(&quot;Cannot find type for url: &quot; + typeUrl);</span>
      }
<span class="nc" id="L712">      ByteString content = (ByteString) message.getField(valueField);</span>
<span class="nc" id="L713">      Message contentMessage =</span>
<span class="nc" id="L714">          DynamicMessage.getDefaultInstance(type).getParserForType().parseFrom(content);</span>
<span class="nc" id="L715">      WellKnownTypePrinter printer = wellKnownTypePrinters.get(typeName);</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">      if (printer != null) {</span>
        // If the type is one of the well-known types, we use a special
        // formatting.
<span class="nc" id="L719">        generator.print(&quot;{&quot; + blankOrNewLine);</span>
<span class="nc" id="L720">        generator.indent();</span>
<span class="nc" id="L721">        generator.print(&quot;\&quot;@type\&quot;:&quot; + blankOrSpace + gson.toJson(typeUrl) + &quot;,&quot; + blankOrNewLine);</span>
<span class="nc" id="L722">        generator.print(&quot;\&quot;value\&quot;:&quot; + blankOrSpace);</span>
<span class="nc" id="L723">        printer.print(this, contentMessage);</span>
<span class="nc" id="L724">        generator.print(blankOrNewLine);</span>
<span class="nc" id="L725">        generator.outdent();</span>
<span class="nc" id="L726">        generator.print(&quot;}&quot;);</span>
      } else {
        // Print the content message instead (with a &quot;@type&quot; field added).
<span class="nc" id="L729">        print(contentMessage, typeUrl);</span>
      }
<span class="nc" id="L731">    }</span>

    /** Prints wrapper types (e.g., google.protobuf.Int32Value) */
    private void printWrapper(MessageOrBuilder message) throws IOException {
<span class="nc" id="L735">      Descriptor descriptor = message.getDescriptorForType();</span>
<span class="nc" id="L736">      FieldDescriptor valueField = descriptor.findFieldByName(&quot;value&quot;);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">      if (valueField == null) {</span>
<span class="nc" id="L738">        throw new InvalidProtocolBufferException(&quot;Invalid Wrapper type.&quot;);</span>
      }
      // When formatting wrapper types, we just print its value field instead of
      // the whole message.
<span class="nc" id="L742">      printSingleFieldValue(valueField, message.getField(valueField));</span>
<span class="nc" id="L743">    }</span>

    private ByteString toByteString(MessageOrBuilder message) {
<span class="nc bnc" id="L746" title="All 2 branches missed.">      if (message instanceof Message) {</span>
<span class="nc" id="L747">        return ((Message) message).toByteString();</span>
      } else {
<span class="nc" id="L749">        return ((Message.Builder) message).build().toByteString();</span>
      }
    }

    /** Prints google.protobuf.Timestamp */
    private void printTimestamp(MessageOrBuilder message) throws IOException {
<span class="nc" id="L755">      Timestamp value = Timestamp.parseFrom(toByteString(message));</span>
<span class="nc" id="L756">      generator.print(&quot;\&quot;&quot; + Timestamps.toString(value) + &quot;\&quot;&quot;);</span>
<span class="nc" id="L757">    }</span>

    /** Prints google.protobuf.Duration */
    private void printDuration(MessageOrBuilder message) throws IOException {
<span class="nc" id="L761">      Duration value = Duration.parseFrom(toByteString(message));</span>
<span class="nc" id="L762">      generator.print(&quot;\&quot;&quot; + Durations.toString(value) + &quot;\&quot;&quot;);</span>
<span class="nc" id="L763">    }</span>

    /** Prints google.protobuf.FieldMask */
    private void printFieldMask(MessageOrBuilder message) throws IOException {
<span class="nc" id="L767">      FieldMask value = FieldMask.parseFrom(toByteString(message));</span>
<span class="nc" id="L768">      generator.print(&quot;\&quot;&quot; + FieldMaskUtil.toJsonString(value) + &quot;\&quot;&quot;);</span>
<span class="nc" id="L769">    }</span>

    /** Prints google.protobuf.Struct */
    private void printStruct(MessageOrBuilder message) throws IOException {
<span class="nc" id="L773">      Descriptor descriptor = message.getDescriptorForType();</span>
<span class="nc" id="L774">      FieldDescriptor field = descriptor.findFieldByName(&quot;fields&quot;);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L776">        throw new InvalidProtocolBufferException(&quot;Invalid Struct type.&quot;);</span>
      }
      // Struct is formatted as a map object.
<span class="nc" id="L779">      printMapFieldValue(field, message.getField(field));</span>
<span class="nc" id="L780">    }</span>

    /** Prints google.protobuf.Value */
    private void printValue(MessageOrBuilder message) throws IOException {
      // For a Value message, only the value of the field is formatted.
<span class="nc" id="L785">      Map&lt;FieldDescriptor, Object&gt; fields = message.getAllFields();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">      if (fields.isEmpty()) {</span>
        // No value set.
<span class="nc" id="L788">        generator.print(&quot;null&quot;);</span>
<span class="nc" id="L789">        return;</span>
      }
      // A Value message can only have at most one field set (it only contains
      // an oneof).
<span class="nc bnc" id="L793" title="All 2 branches missed.">      if (fields.size() != 1) {</span>
<span class="nc" id="L794">        throw new InvalidProtocolBufferException(&quot;Invalid Value type.&quot;);</span>
      }
<span class="nc bnc" id="L796" title="All 2 branches missed.">      for (Map.Entry&lt;FieldDescriptor, Object&gt; entry : fields.entrySet()) {</span>
<span class="nc" id="L797">        printSingleFieldValue(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L798">      }</span>
<span class="nc" id="L799">    }</span>

    /** Prints google.protobuf.ListValue */
    private void printListValue(MessageOrBuilder message) throws IOException {
<span class="nc" id="L803">      Descriptor descriptor = message.getDescriptorForType();</span>
<span class="nc" id="L804">      FieldDescriptor field = descriptor.findFieldByName(&quot;values&quot;);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L806">        throw new InvalidProtocolBufferException(&quot;Invalid ListValue type.&quot;);</span>
      }
<span class="nc" id="L808">      printRepeatedFieldValue(field, message.getField(field));</span>
<span class="nc" id="L809">    }</span>

    /** Prints a regular message with an optional type URL. */
    private void print(MessageOrBuilder message, String typeUrl) throws IOException {
<span class="fc" id="L813">      generator.print(&quot;{&quot; + blankOrNewLine);</span>
<span class="fc" id="L814">      generator.indent();</span>

<span class="fc" id="L816">      boolean printedField = false;</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">      if (typeUrl != null) {</span>
<span class="nc" id="L818">        generator.print(&quot;\&quot;@type\&quot;:&quot; + blankOrSpace + gson.toJson(typeUrl));</span>
<span class="nc" id="L819">        printedField = true;</span>
      }
<span class="fc" id="L821">      Map&lt;FieldDescriptor, Object&gt; fieldsToPrint = null;</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">      if (includingDefaultValueFields) {</span>
<span class="nc" id="L823">        fieldsToPrint = new TreeMap&lt;FieldDescriptor, Object&gt;();</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        for (FieldDescriptor field : message.getDescriptorForType().getFields()) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">          if (field.isOptional()) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                &amp;&amp; !message.hasField(field)){</span>
              // Always skip empty optional message fields. If not we will recurse indefinitely if
              // a message has itself as a sub-field.
<span class="nc" id="L830">              continue;</span>
            }
<span class="nc" id="L832">            OneofDescriptor oneof = field.getContainingOneof();</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">            if (oneof != null &amp;&amp; !message.hasField(field)) {</span>
                // Skip all oneof fields except the one that is actually set
<span class="nc" id="L835">              continue;</span>
            }
          }
<span class="nc" id="L838">          fieldsToPrint.put(field, message.getField(field));</span>
<span class="nc" id="L839">        }</span>
      } else {
<span class="fc" id="L841">        fieldsToPrint = message.getAllFields();</span>
      }
<span class="fc bfc" id="L843" title="All 2 branches covered.">      for (Map.Entry&lt;FieldDescriptor, Object&gt; field : fieldsToPrint.entrySet()) {</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">        if (printedField) {</span>
          // Add line-endings for the previous field.
<span class="fc" id="L846">          generator.print(&quot;,&quot; + blankOrNewLine);</span>
        } else {
<span class="fc" id="L848">          printedField = true;</span>
        }
<span class="fc" id="L850">        printField(field.getKey(), field.getValue());</span>
<span class="fc" id="L851">      }</span>

      // Add line-endings for the last field.
<span class="fc bfc" id="L854" title="All 2 branches covered.">      if (printedField) {</span>
<span class="fc" id="L855">        generator.print(blankOrNewLine);</span>
      }
<span class="fc" id="L857">      generator.outdent();</span>
<span class="fc" id="L858">      generator.print(&quot;}&quot;);</span>
<span class="fc" id="L859">    }</span>

    private void printField(FieldDescriptor field, Object value) throws IOException {
<span class="fc bfc" id="L862" title="All 2 branches covered.">      if (preservingProtoFieldNames) {</span>
<span class="fc" id="L863">        generator.print(&quot;\&quot;&quot; + field.getName() + &quot;\&quot;:&quot; + blankOrSpace);</span>
      } else {
<span class="fc" id="L865">        generator.print(&quot;\&quot;&quot; + field.getJsonName() + &quot;\&quot;:&quot; + blankOrSpace);</span>
      }
<span class="fc bfc" id="L867" title="All 2 branches covered.">      if (field.isMapField()) {</span>
<span class="fc" id="L868">        printMapFieldValue(field, value);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">      } else if (field.isRepeated()) {</span>
<span class="fc" id="L870">        printRepeatedFieldValue(field, value);</span>
      } else {
<span class="fc" id="L872">        printSingleFieldValue(field, value);</span>
      }
<span class="fc" id="L874">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    private void printRepeatedFieldValue(FieldDescriptor field, Object value) throws IOException {
<span class="fc" id="L878">      generator.print(&quot;[&quot;);</span>
<span class="fc" id="L879">      boolean printedElement = false;</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">      for (Object element : (List) value) {</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (printedElement) {</span>
<span class="fc" id="L882">          generator.print(&quot;,&quot; + blankOrSpace);</span>
        } else {
<span class="fc" id="L884">          printedElement = true;</span>
        }
<span class="fc" id="L886">        printSingleFieldValue(field, element);</span>
<span class="fc" id="L887">      }</span>
<span class="fc" id="L888">      generator.print(&quot;]&quot;);</span>
<span class="fc" id="L889">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    private void printMapFieldValue(FieldDescriptor field, Object value) throws IOException {
<span class="fc" id="L893">      Descriptor type = field.getMessageType();</span>
<span class="fc" id="L894">      FieldDescriptor keyField = type.findFieldByName(&quot;key&quot;);</span>
<span class="fc" id="L895">      FieldDescriptor valueField = type.findFieldByName(&quot;value&quot;);</span>
<span class="pc bpc" id="L896" title="2 of 4 branches missed.">      if (keyField == null || valueField == null) {</span>
<span class="nc" id="L897">        throw new InvalidProtocolBufferException(&quot;Invalid map field.&quot;);</span>
      }
<span class="fc" id="L899">      generator.print(&quot;{&quot; + blankOrNewLine);</span>
<span class="fc" id="L900">      generator.indent();</span>
<span class="fc" id="L901">      boolean printedElement = false;</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">      for (Object element : (List) value) {</span>
<span class="fc" id="L903">        Message entry = (Message) element;</span>
<span class="fc" id="L904">        Object entryKey = entry.getField(keyField);</span>
<span class="fc" id="L905">        Object entryValue = entry.getField(valueField);</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        if (printedElement) {</span>
<span class="fc" id="L907">          generator.print(&quot;,&quot; + blankOrNewLine);</span>
        } else {
<span class="fc" id="L909">          printedElement = true;</span>
        }
        // Key fields are always double-quoted.
<span class="fc" id="L912">        printSingleFieldValue(keyField, entryKey, true);</span>
<span class="fc" id="L913">        generator.print(&quot;:&quot; + blankOrSpace);</span>
<span class="fc" id="L914">        printSingleFieldValue(valueField, entryValue);</span>
<span class="fc" id="L915">      }</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">      if (printedElement) {</span>
<span class="fc" id="L917">        generator.print(blankOrNewLine);</span>
      }
<span class="fc" id="L919">      generator.outdent();</span>
<span class="fc" id="L920">      generator.print(&quot;}&quot;);</span>
<span class="fc" id="L921">    }</span>

    private void printSingleFieldValue(FieldDescriptor field, Object value) throws IOException {
<span class="fc" id="L924">      printSingleFieldValue(field, value, false);</span>
<span class="fc" id="L925">    }</span>

    /**
     * Prints a field's value in JSON format.
     *
     * @param alwaysWithQuotes whether to always add double-quotes to primitive
     *        types.
     */
    private void printSingleFieldValue(
        final FieldDescriptor field, final Object value, boolean alwaysWithQuotes)
        throws IOException {
<span class="pc bpc" id="L936" title="6 of 12 branches missed.">      switch (field.getType()) {</span>
        case INT32:
        case SINT32:
        case SFIXED32:
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L941">            generator.print(&quot;\&quot;&quot;);</span>
          }
<span class="fc" id="L943">          generator.print(((Integer) value).toString());</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L945">            generator.print(&quot;\&quot;&quot;);</span>
          }
          break;

        case INT64:
        case SINT64:
        case SFIXED64:
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L953">                generator.print(&quot;\&quot;&quot;);</span>
          }
<span class="fc" id="L955">          generator.print(((Long) value).toString());</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L957">                generator.print(&quot;\&quot;&quot;);</span>
          }
          break;

        case BOOL:
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L963">            generator.print(&quot;\&quot;&quot;);</span>
          }
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">          if (((Boolean) value).booleanValue()) {</span>
<span class="fc" id="L966">            generator.print(&quot;true&quot;);</span>
          } else {
<span class="nc" id="L968">            generator.print(&quot;false&quot;);</span>
          }
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L971">            generator.print(&quot;\&quot;&quot;);</span>
          }
          break;

        case FLOAT:
<span class="nc" id="L976">          Float floatValue = (Float) value;</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">          if (floatValue.isNaN()) {</span>
<span class="nc" id="L978">            generator.print(&quot;\&quot;NaN\&quot;&quot;);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">          } else if (floatValue.isInfinite()) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (floatValue &lt; 0) {</span>
<span class="nc" id="L981">              generator.print(&quot;\&quot;-Infinity\&quot;&quot;);</span>
            } else {
<span class="nc" id="L983">              generator.print(&quot;\&quot;Infinity\&quot;&quot;);</span>
            }
          } else {
<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L987">              generator.print(&quot;\&quot;&quot;);</span>
            }
<span class="nc" id="L989">            generator.print(floatValue.toString());</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L991">              generator.print(&quot;\&quot;&quot;);</span>
            }
          }
          break;

        case DOUBLE:
<span class="nc" id="L997">          Double doubleValue = (Double) value;</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">          if (doubleValue.isNaN()) {</span>
<span class="nc" id="L999">            generator.print(&quot;\&quot;NaN\&quot;&quot;);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">          } else if (doubleValue.isInfinite()) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (doubleValue &lt; 0) {</span>
<span class="nc" id="L1002">              generator.print(&quot;\&quot;-Infinity\&quot;&quot;);</span>
            } else {
<span class="nc" id="L1004">              generator.print(&quot;\&quot;Infinity\&quot;&quot;);</span>
            }
          } else {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L1008">              generator.print(&quot;\&quot;&quot;);</span>
            }
<span class="nc" id="L1010">            generator.print(doubleValue.toString());</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L1012">              generator.print(&quot;\&quot;&quot;);</span>
            }
          }
          break;

        case UINT32:
        case FIXED32:
<span class="nc bnc" id="L1019" title="All 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L1020">            generator.print(&quot;\&quot;&quot;);</span>
          }
<span class="nc" id="L1022">          generator.print(unsignedToString((Integer) value));</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">          if (alwaysWithQuotes) {</span>
<span class="nc" id="L1024">            generator.print(&quot;\&quot;&quot;);</span>
          }
          break;

        case UINT64:
        case FIXED64:
<span class="nc" id="L1030">          generator.print(&quot;\&quot;&quot; + unsignedToString((Long) value) + &quot;\&quot;&quot;);</span>
<span class="nc" id="L1031">          break;</span>

        case STRING:
<span class="fc" id="L1034">          generator.print(gson.toJson(value));</span>
<span class="fc" id="L1035">          break;</span>

        case BYTES:
<span class="nc" id="L1038">          generator.print(&quot;\&quot;&quot;);</span>
<span class="nc" id="L1039">          generator.print(BaseEncoding.base64().encode(((ByteString) value).toByteArray()));</span>
<span class="nc" id="L1040">          generator.print(&quot;\&quot;&quot;);</span>
<span class="nc" id="L1041">          break;</span>

        case ENUM:
          // Special-case google.protobuf.NullValue (it's an Enum).
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">          if (field.getEnumType().getFullName().equals(&quot;google.protobuf.NullValue&quot;)) {</span>
            // No matter what value it contains, we always print it as &quot;null&quot;.
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L1048">              generator.print(&quot;\&quot;&quot;);</span>
            }
<span class="nc" id="L1050">            generator.print(&quot;null&quot;);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            if (alwaysWithQuotes) {</span>
<span class="nc" id="L1052">              generator.print(&quot;\&quot;&quot;);</span>
            }
          } else {
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">            if (((EnumValueDescriptor) value).getIndex() == -1) {</span>
<span class="nc" id="L1056">              generator.print(String.valueOf(((EnumValueDescriptor) value).getNumber()));</span>
            } else {
<span class="fc" id="L1058">              generator.print(&quot;\&quot;&quot; + ((EnumValueDescriptor) value).getName() + &quot;\&quot;&quot;);</span>
            }
          }
<span class="fc" id="L1061">          break;</span>

        case MESSAGE:
        case GROUP:
<span class="fc" id="L1065">          print((Message) value);</span>
          break;
      }
<span class="fc" id="L1068">    }</span>
  }

  /** Convert an unsigned 32-bit integer to a string. */
  private static String unsignedToString(final int value) {
<span class="nc bnc" id="L1073" title="All 2 branches missed.">    if (value &gt;= 0) {</span>
<span class="nc" id="L1074">      return Integer.toString(value);</span>
    } else {
<span class="nc" id="L1076">      return Long.toString(value &amp; 0x00000000FFFFFFFFL);</span>
    }
  }

  /** Convert an unsigned 64-bit integer to a string. */
  private static String unsignedToString(final long value) {
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    if (value &gt;= 0) {</span>
<span class="nc" id="L1083">      return Long.toString(value);</span>
    } else {
      // Pull off the most-significant bit so that BigInteger doesn't think
      // the number is negative, then set it again using setBit().
<span class="nc" id="L1087">      return BigInteger.valueOf(value &amp; Long.MAX_VALUE).setBit(Long.SIZE - 1).toString();</span>
    }
  }

  private static String getTypeName(String typeUrl) throws InvalidProtocolBufferException {
<span class="nc" id="L1092">    String[] parts = typeUrl.split(&quot;/&quot;);</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">    if (parts.length == 1) {</span>
<span class="nc" id="L1094">      throw new InvalidProtocolBufferException(&quot;Invalid type url found: &quot; + typeUrl);</span>
    }
<span class="nc" id="L1096">    return parts[parts.length - 1];</span>
  }

  private static class ParserImpl {
    private final TypeRegistry registry;
    private final Map&lt;String,TypeParser&gt; typeParsers;
    private final JsonParser jsonParser;
    private final boolean ignoringUnknownFields;
    private final int recursionLimit;
    private int currentDepth;

<span class="fc" id="L1107">    ParserImpl(TypeRegistry registry, boolean ignoreUnknownFields, int recursionLimit,Map&lt;String,TypeParser&gt; typeParsers) {</span>
<span class="fc" id="L1108">      this.registry = registry;</span>
<span class="fc" id="L1109">      this.ignoringUnknownFields = ignoreUnknownFields;</span>
<span class="fc" id="L1110">      this.jsonParser = new JsonParser();</span>
<span class="fc" id="L1111">      this.recursionLimit = recursionLimit;</span>
<span class="fc" id="L1112">      this.currentDepth = 0;</span>
<span class="fc" id="L1113">      this.typeParsers = typeParsers;</span>
<span class="fc" id="L1114">    }</span>

    void merge(Reader json, Message.Builder builder) throws IOException {
<span class="nc" id="L1117">      JsonReader reader = new JsonReader(json);</span>
<span class="nc" id="L1118">      reader.setLenient(false);</span>
<span class="nc" id="L1119">      merge(jsonParser.parse(reader), builder);</span>
<span class="nc" id="L1120">    }</span>

    void merge(String json, Message.Builder builder) throws InvalidProtocolBufferException {
      try {
<span class="fc" id="L1124">        JsonReader reader = new JsonReader(new StringReader(json));</span>
<span class="fc" id="L1125">        reader.setLenient(false);</span>
<span class="fc" id="L1126">        merge(jsonParser.parse(reader), builder);</span>
<span class="fc" id="L1127">      } catch (InvalidProtocolBufferException e) {</span>
<span class="fc" id="L1128">        throw e;</span>
<span class="nc" id="L1129">      } catch (Exception e) {</span>
        // We convert all exceptions from JSON parsing to our own exceptions.
<span class="nc" id="L1131">        throw new InvalidProtocolBufferException(e.getMessage());</span>
<span class="fc" id="L1132">      }</span>
<span class="fc" id="L1133">    }</span>

    private interface WellKnownTypeParser {
      void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
          throws InvalidProtocolBufferException;
    }

    private static final Map&lt;String, WellKnownTypeParser&gt; wellKnownTypeParsers =
<span class="fc" id="L1141">        buildWellKnownTypeParsers();</span>

    private static Map&lt;String, WellKnownTypeParser&gt; buildWellKnownTypeParsers() {
<span class="fc" id="L1144">      Map&lt;String, WellKnownTypeParser&gt; parsers = new HashMap&lt;String, WellKnownTypeParser&gt;();</span>
      // Special-case Any.
<span class="fc" id="L1146">      parsers.put(</span>
<span class="fc" id="L1147">          Any.getDescriptor().getFullName(),</span>
<span class="fc" id="L1148">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1152">              parser.mergeAny(json, builder);</span>
<span class="nc" id="L1153">            }</span>
          });
      // Special-case wrapper types.
<span class="fc" id="L1156">      WellKnownTypeParser wrappersPrinter =</span>
<span class="fc" id="L1157">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1161">              parser.mergeWrapper(json, builder);</span>
<span class="nc" id="L1162">            }</span>
          };
<span class="fc" id="L1164">      parsers.put(BoolValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1165">      parsers.put(Int32Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1166">      parsers.put(UInt32Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1167">      parsers.put(Int64Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1168">      parsers.put(UInt64Value.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1169">      parsers.put(StringValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1170">      parsers.put(BytesValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1171">      parsers.put(FloatValue.getDescriptor().getFullName(), wrappersPrinter);</span>
<span class="fc" id="L1172">      parsers.put(DoubleValue.getDescriptor().getFullName(), wrappersPrinter);</span>
      // Special-case Timestamp.
<span class="fc" id="L1174">      parsers.put(</span>
<span class="fc" id="L1175">          Timestamp.getDescriptor().getFullName(),</span>
<span class="fc" id="L1176">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1180">              parser.mergeTimestamp(json, builder);</span>
<span class="nc" id="L1181">            }</span>
          });
      // Special-case Duration.
<span class="fc" id="L1184">      parsers.put(</span>
<span class="fc" id="L1185">          Duration.getDescriptor().getFullName(),</span>
<span class="fc" id="L1186">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1190">              parser.mergeDuration(json, builder);</span>
<span class="nc" id="L1191">            }</span>
          });
      // Special-case FieldMask.
<span class="fc" id="L1194">      parsers.put(</span>
<span class="fc" id="L1195">          FieldMask.getDescriptor().getFullName(),</span>
<span class="fc" id="L1196">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1200">              parser.mergeFieldMask(json, builder);</span>
<span class="nc" id="L1201">            }</span>
          });
      // Special-case Struct.
<span class="fc" id="L1204">      parsers.put(</span>
<span class="fc" id="L1205">          Struct.getDescriptor().getFullName(),</span>
<span class="fc" id="L1206">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1210">              parser.mergeStruct(json, builder);</span>
<span class="nc" id="L1211">            }</span>
          });
      // Special-case ListValue.
<span class="fc" id="L1214">      parsers.put(</span>
<span class="fc" id="L1215">          ListValue.getDescriptor().getFullName(),</span>
<span class="fc" id="L1216">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1220">              parser.mergeListValue(json, builder);</span>
<span class="nc" id="L1221">            }</span>
          });
      // Special-case Value.
<span class="fc" id="L1224">      parsers.put(</span>
<span class="fc" id="L1225">          Value.getDescriptor().getFullName(),</span>
<span class="fc" id="L1226">          new WellKnownTypeParser() {</span>
            @Override
            public void merge(ParserImpl parser, JsonElement json, Message.Builder builder)
                throws InvalidProtocolBufferException {
<span class="nc" id="L1230">              parser.mergeValue(json, builder);</span>
<span class="nc" id="L1231">            }</span>
          });
<span class="fc" id="L1233">      return parsers;</span>
    }

    private void merge(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
        
<span class="fc bfc" id="L1239" title="All 2 branches covered.">        if (typeParsers.containsKey(builder.getDescriptorForType().getFullName()))</span>
        {
<span class="fc" id="L1241">            typeParsers.get(builder.getDescriptorForType().getFullName()).merge(json, builder);</span>
<span class="fc" id="L1242">            return;</span>
        }
        
<span class="fc" id="L1245">        WellKnownTypeParser specialParser =</span>
<span class="fc" id="L1246">                wellKnownTypeParsers.get(builder.getDescriptorForType().getFullName());</span>
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        if (specialParser != null) {</span>
<span class="nc" id="L1248">            specialParser.merge(this, json, builder);</span>
<span class="nc" id="L1249">            return;</span>
        }
      
<span class="fc" id="L1252">        mergeMessage(json, builder, false);</span>
<span class="fc" id="L1253">    }</span>

    // Maps from camel-case field names to FieldDescriptor.
<span class="fc" id="L1256">    private final Map&lt;Descriptor, Map&lt;String, FieldDescriptor&gt;&gt; fieldNameMaps =</span>
        new HashMap&lt;Descriptor, Map&lt;String, FieldDescriptor&gt;&gt;();

    private Map&lt;String, FieldDescriptor&gt; getFieldNameMap(Descriptor descriptor) {
<span class="fc bfc" id="L1260" title="All 2 branches covered.">      if (!fieldNameMaps.containsKey(descriptor)) {</span>
<span class="fc" id="L1261">        Map&lt;String, FieldDescriptor&gt; fieldNameMap = new HashMap&lt;String, FieldDescriptor&gt;();</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        for (FieldDescriptor field : descriptor.getFields()) {</span>
<span class="fc" id="L1263">          fieldNameMap.put(field.getName(), field);</span>
<span class="fc" id="L1264">          fieldNameMap.put(field.getJsonName(), field);</span>
<span class="fc" id="L1265">        }</span>
<span class="fc" id="L1266">        fieldNameMaps.put(descriptor, fieldNameMap);</span>
<span class="fc" id="L1267">        return fieldNameMap;</span>
      }
<span class="fc" id="L1269">      return fieldNameMaps.get(descriptor);</span>
    }

    private void mergeMessage(JsonElement json, Message.Builder builder, boolean skipTypeUrl)
        throws InvalidProtocolBufferException {
<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">      if (!(json instanceof JsonObject)) {</span>
<span class="nc" id="L1275">        throw new InvalidProtocolBufferException(&quot;Expect message object but got: &quot; + json);</span>
      }
<span class="fc" id="L1277">      JsonObject object = (JsonObject) json;</span>
<span class="fc" id="L1278">      Map&lt;String, FieldDescriptor&gt; fieldNameMap = getFieldNameMap(builder.getDescriptorForType());</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">      for (Map.Entry&lt;String, JsonElement&gt; entry : object.entrySet()) {</span>
<span class="pc bpc" id="L1280" title="3 of 4 branches missed.">        if (skipTypeUrl &amp;&amp; entry.getKey().equals(&quot;@type&quot;)) {</span>
<span class="nc" id="L1281">          continue;</span>
        }
<span class="fc" id="L1283">        FieldDescriptor field = fieldNameMap.get(entry.getKey());</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        if (field == null) {</span>
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">          if (ignoringUnknownFields) {</span>
<span class="nc" id="L1286">            continue;</span>
          }
<span class="fc" id="L1288">          throw new InvalidProtocolBufferException(</span>
              &quot;Cannot find field: &quot;
<span class="fc" id="L1290">                  + entry.getKey()</span>
                  + &quot; in message &quot;
<span class="fc" id="L1292">                  + builder.getDescriptorForType().getFullName());</span>
        }
<span class="fc" id="L1294">        mergeField(field, entry.getValue(), builder);</span>
<span class="fc" id="L1295">      }</span>
<span class="fc" id="L1296">    }</span>

    private void mergeAny(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1300">      Descriptor descriptor = builder.getDescriptorForType();</span>
<span class="nc" id="L1301">      FieldDescriptor typeUrlField = descriptor.findFieldByName(&quot;type_url&quot;);</span>
<span class="nc" id="L1302">      FieldDescriptor valueField = descriptor.findFieldByName(&quot;value&quot;);</span>
      // Validates type of the message. Note that we can't just cast the message
      // to com.google.protobuf.Any because it might be a DynamicMessage.
<span class="nc bnc" id="L1305" title="All 4 branches missed.">      if (typeUrlField == null</span>
          || valueField == null
<span class="nc bnc" id="L1307" title="All 2 branches missed.">          || typeUrlField.getType() != FieldDescriptor.Type.STRING</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">          || valueField.getType() != FieldDescriptor.Type.BYTES) {</span>
<span class="nc" id="L1309">        throw new InvalidProtocolBufferException(&quot;Invalid Any type.&quot;);</span>
      }

<span class="nc bnc" id="L1312" title="All 2 branches missed.">      if (!(json instanceof JsonObject)) {</span>
<span class="nc" id="L1313">        throw new InvalidProtocolBufferException(&quot;Expect message object but got: &quot; + json);</span>
      }
<span class="nc" id="L1315">      JsonObject object = (JsonObject) json;</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">      if (object.entrySet().isEmpty()) {</span>
<span class="nc" id="L1317">        return; // builder never modified, so it will end up building the default instance of Any</span>
      }
<span class="nc" id="L1319">      JsonElement typeUrlElement = object.get(&quot;@type&quot;);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">      if (typeUrlElement == null) {</span>
<span class="nc" id="L1321">        throw new InvalidProtocolBufferException(&quot;Missing type url when parsing: &quot; + json);</span>
      }
<span class="nc" id="L1323">      String typeUrl = typeUrlElement.getAsString();</span>
<span class="nc" id="L1324">      Descriptor contentType = registry.find(getTypeName(typeUrl));</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">      if (contentType == null) {</span>
<span class="nc" id="L1326">        throw new InvalidProtocolBufferException(&quot;Cannot resolve type: &quot; + typeUrl);</span>
      }
<span class="nc" id="L1328">      builder.setField(typeUrlField, typeUrl);</span>
<span class="nc" id="L1329">      Message.Builder contentBuilder =</span>
<span class="nc" id="L1330">          DynamicMessage.getDefaultInstance(contentType).newBuilderForType();</span>
<span class="nc" id="L1331">      WellKnownTypeParser specialParser = wellKnownTypeParsers.get(contentType.getFullName());</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">      if (specialParser != null) {</span>
<span class="nc" id="L1333">        JsonElement value = object.get(&quot;value&quot;);</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1335">          specialParser.merge(this, value, contentBuilder);</span>
        }
<span class="nc" id="L1337">      } else {</span>
<span class="nc" id="L1338">        mergeMessage(json, contentBuilder, true);</span>
      }
<span class="nc" id="L1340">      builder.setField(valueField, contentBuilder.build().toByteString());</span>
<span class="nc" id="L1341">    }</span>

    private void mergeFieldMask(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1345">      FieldMask value = FieldMaskUtil.fromJsonString(json.getAsString());</span>
<span class="nc" id="L1346">      builder.mergeFrom(value.toByteString());</span>
<span class="nc" id="L1347">    }</span>

    private void mergeTimestamp(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
      try {
<span class="nc" id="L1352">        Timestamp value = Timestamps.parse(json.getAsString());</span>
<span class="nc" id="L1353">        builder.mergeFrom(value.toByteString());</span>
<span class="nc" id="L1354">      } catch (ParseException e) {</span>
<span class="nc" id="L1355">        throw new InvalidProtocolBufferException(&quot;Failed to parse timestamp: &quot; + json);</span>
<span class="nc" id="L1356">      }</span>
<span class="nc" id="L1357">    }</span>

    private void mergeDuration(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
      try {
<span class="nc" id="L1362">        Duration value = Durations.parse(json.getAsString());</span>
<span class="nc" id="L1363">        builder.mergeFrom(value.toByteString());</span>
<span class="nc" id="L1364">      } catch (ParseException e) {</span>
<span class="nc" id="L1365">        throw new InvalidProtocolBufferException(&quot;Failed to parse duration: &quot; + json);</span>
<span class="nc" id="L1366">      }</span>
<span class="nc" id="L1367">    }</span>

    private void mergeStruct(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1371">      Descriptor descriptor = builder.getDescriptorForType();</span>
<span class="nc" id="L1372">      FieldDescriptor field = descriptor.findFieldByName(&quot;fields&quot;);</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L1374">        throw new InvalidProtocolBufferException(&quot;Invalid Struct type.&quot;);</span>
      }
<span class="nc" id="L1376">      mergeMapField(field, json, builder);</span>
<span class="nc" id="L1377">    }</span>

    private void mergeListValue(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1381">      Descriptor descriptor = builder.getDescriptorForType();</span>
<span class="nc" id="L1382">      FieldDescriptor field = descriptor.findFieldByName(&quot;values&quot;);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L1384">        throw new InvalidProtocolBufferException(&quot;Invalid ListValue type.&quot;);</span>
      }
<span class="nc" id="L1386">      mergeRepeatedField(field, json, builder);</span>
<span class="nc" id="L1387">    }</span>

    private void mergeValue(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1391">      Descriptor type = builder.getDescriptorForType();</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">      if (json instanceof JsonPrimitive) {</span>
<span class="nc" id="L1393">        JsonPrimitive primitive = (JsonPrimitive) json;</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (primitive.isBoolean()) {</span>
<span class="nc" id="L1395">          builder.setField(type.findFieldByName(&quot;bool_value&quot;), primitive.getAsBoolean());</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        } else if (primitive.isNumber()) {</span>
<span class="nc" id="L1397">          builder.setField(type.findFieldByName(&quot;number_value&quot;), primitive.getAsDouble());</span>
        } else {
<span class="nc" id="L1399">          builder.setField(type.findFieldByName(&quot;string_value&quot;), primitive.getAsString());</span>
        }
<span class="nc bnc" id="L1401" title="All 2 branches missed.">      } else if (json instanceof JsonObject) {</span>
<span class="nc" id="L1402">        FieldDescriptor field = type.findFieldByName(&quot;struct_value&quot;);</span>
<span class="nc" id="L1403">        Message.Builder structBuilder = builder.newBuilderForField(field);</span>
<span class="nc" id="L1404">        merge(json, structBuilder);</span>
<span class="nc" id="L1405">        builder.setField(field, structBuilder.build());</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">      } else if (json instanceof JsonArray) {</span>
<span class="nc" id="L1407">        FieldDescriptor field = type.findFieldByName(&quot;list_value&quot;);</span>
<span class="nc" id="L1408">        Message.Builder listBuilder = builder.newBuilderForField(field);</span>
<span class="nc" id="L1409">        merge(json, listBuilder);</span>
<span class="nc" id="L1410">        builder.setField(field, listBuilder.build());</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">      } else if (json instanceof JsonNull) {</span>
<span class="nc" id="L1412">        builder.setField(</span>
<span class="nc" id="L1413">            type.findFieldByName(&quot;null_value&quot;), NullValue.NULL_VALUE.getValueDescriptor());</span>
      } else {
<span class="nc" id="L1415">        throw new IllegalStateException(&quot;Unexpected json data: &quot; + json);</span>
      }
<span class="nc" id="L1417">    }</span>

    private void mergeWrapper(JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="nc" id="L1421">      Descriptor type = builder.getDescriptorForType();</span>
<span class="nc" id="L1422">      FieldDescriptor field = type.findFieldByName(&quot;value&quot;);</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L1424">        throw new InvalidProtocolBufferException(&quot;Invalid wrapper type: &quot; + type.getFullName());</span>
      }
<span class="nc" id="L1426">      builder.setField(field, parseFieldValue(field, json, builder));</span>
<span class="nc" id="L1427">    }</span>

    private void mergeField(FieldDescriptor field, JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="fc bfc" id="L1431" title="All 2 branches covered.">      if (field.isRepeated()) {</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        if (builder.getRepeatedFieldCount(field) &gt; 0) {</span>
<span class="nc" id="L1433">          throw new InvalidProtocolBufferException(</span>
<span class="nc" id="L1434">              &quot;Field &quot; + field.getFullName() + &quot; has already been set.&quot;);</span>
        }
      } else {
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">        if (builder.hasField(field)) {</span>
<span class="nc" id="L1438">          throw new InvalidProtocolBufferException(</span>
<span class="nc" id="L1439">              &quot;Field &quot; + field.getFullName() + &quot; has already been set.&quot;);</span>
        }
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">        if (field.getContainingOneof() != null</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">            &amp;&amp; builder.getOneofFieldDescriptor(field.getContainingOneof()) != null) {</span>
<span class="nc" id="L1443">          FieldDescriptor other = builder.getOneofFieldDescriptor(field.getContainingOneof());</span>
<span class="nc" id="L1444">          throw new InvalidProtocolBufferException(</span>
              &quot;Cannot set field &quot;
<span class="nc" id="L1446">                  + field.getFullName()</span>
                  + &quot; because another field &quot;
<span class="nc" id="L1448">                  + other.getFullName()</span>
                  + &quot; belonging to the same oneof has already been set &quot;);
        }
      }
<span class="pc bpc" id="L1452" title="1 of 4 branches missed.">      if (field.isRepeated() &amp;&amp; json instanceof JsonNull) {</span>
        // We allow &quot;null&quot; as value for all field types and treat it as if the
        // field is not present.
<span class="nc" id="L1455">        return;</span>
      }
<span class="fc bfc" id="L1457" title="All 2 branches covered.">      if (field.isMapField()) {</span>
<span class="fc" id="L1458">        mergeMapField(field, json, builder);</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">      } else if (field.isRepeated()) {</span>
<span class="fc" id="L1460">        mergeRepeatedField(field, json, builder);</span>
      } else {
<span class="fc" id="L1462">        Object value = parseFieldValue(field, json, builder);</span>
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L1464">          builder.setField(field, value);</span>
        }
      }
<span class="fc" id="L1467">    }</span>

    private void mergeMapField(FieldDescriptor field, JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="pc bpc" id="L1471" title="1 of 2 branches missed.">      if (!(json instanceof JsonObject)) {</span>
<span class="nc" id="L1472">        throw new InvalidProtocolBufferException(&quot;Expect a map object but found: &quot; + json);</span>
      }
<span class="fc" id="L1474">      Descriptor type = field.getMessageType();</span>
<span class="fc" id="L1475">      FieldDescriptor keyField = type.findFieldByName(&quot;key&quot;);</span>
<span class="fc" id="L1476">      FieldDescriptor valueField = type.findFieldByName(&quot;value&quot;);</span>
<span class="pc bpc" id="L1477" title="2 of 4 branches missed.">      if (keyField == null || valueField == null) {</span>
<span class="nc" id="L1478">        throw new InvalidProtocolBufferException(&quot;Invalid map field: &quot; + field.getFullName());</span>
      }
<span class="fc" id="L1480">      JsonObject object = (JsonObject) json;</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">      for (Map.Entry&lt;String, JsonElement&gt; entry : object.entrySet()) {</span>
<span class="fc" id="L1482">        Message.Builder entryBuilder = builder.newBuilderForField(field);</span>
<span class="fc" id="L1483">        Object key = parseFieldValue(keyField, new JsonPrimitive(entry.getKey()), entryBuilder);</span>
<span class="fc" id="L1484">        Object value = parseFieldValue(valueField, entry.getValue(), entryBuilder);</span>
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1486">          throw new InvalidProtocolBufferException(&quot;Map value cannot be null.&quot;);</span>
        }
<span class="fc" id="L1488">        entryBuilder.setField(keyField, key);</span>
<span class="fc" id="L1489">        entryBuilder.setField(valueField, value);</span>
<span class="fc" id="L1490">        builder.addRepeatedField(field, entryBuilder.build());</span>
<span class="fc" id="L1491">      }</span>
<span class="fc" id="L1492">    }</span>

    /**
     * Gets the default value for a field type. Note that we use proto3
     * language defaults and ignore any default values set through the
     * proto &quot;default&quot; option.
     */
    private Object getDefaultValue(FieldDescriptor field, Message.Builder builder) {
<span class="nc bnc" id="L1500" title="All 10 branches missed.">      switch (field.getType()) {</span>
        case INT32:
        case SINT32:
        case SFIXED32:
        case UINT32:
        case FIXED32:
<span class="nc" id="L1506">          return 0;</span>
        case INT64:
        case SINT64:
        case SFIXED64:
        case UINT64:
        case FIXED64:
<span class="nc" id="L1512">          return 0L;</span>
        case FLOAT:
<span class="nc" id="L1514">          return 0.0f;</span>
        case DOUBLE:
<span class="nc" id="L1516">          return 0.0;</span>
        case BOOL:
<span class="nc" id="L1518">          return false;</span>
        case STRING:
<span class="nc" id="L1520">          return &quot;&quot;;</span>
        case BYTES:
<span class="nc" id="L1522">          return ByteString.EMPTY;</span>
        case ENUM:
<span class="nc" id="L1524">          return field.getEnumType().getValues().get(0);</span>
        case MESSAGE:
        case GROUP:
<span class="nc" id="L1527">          return builder.newBuilderForField(field).getDefaultInstanceForType();</span>
        default:
<span class="nc" id="L1529">          throw new IllegalStateException(&quot;Invalid field type: &quot; + field.getType());</span>
      }
    }

    private void mergeRepeatedField(
        FieldDescriptor field, JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">      if (!(json instanceof JsonArray)) {</span>
<span class="nc" id="L1537">        throw new InvalidProtocolBufferException(&quot;Expect an array but found: &quot; + json);</span>
      }
<span class="fc" id="L1539">      JsonArray array = (JsonArray) json;</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">      for (int i = 0; i &lt; array.size(); ++i) {</span>
<span class="fc" id="L1541">        Object value = parseFieldValue(field, array.get(i), builder);</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1543">          throw new InvalidProtocolBufferException(&quot;Repeated field elements cannot be null&quot;);</span>
        }
<span class="fc" id="L1545">        builder.addRepeatedField(field, value);</span>
      }
<span class="fc" id="L1547">    }</span>

    private int parseInt32(JsonElement json) throws InvalidProtocolBufferException {
      try {
<span class="fc" id="L1551">        return Integer.parseInt(json.getAsString());</span>
<span class="fc" id="L1552">      } catch (Exception e) {</span>
        // Fall through.
      }
      // JSON doesn't distinguish between integer values and floating point values so &quot;1&quot; and
      // &quot;1.000&quot; are treated as equal in JSON. For this reason we accept floating point values for
      // integer fields as well as long as it actually is an integer (i.e., round(value) == value).
      try {
<span class="fc" id="L1559">        BigDecimal value = new BigDecimal(json.getAsString());</span>
<span class="fc" id="L1560">        return value.intValueExact();</span>
<span class="nc" id="L1561">      } catch (Exception e) {</span>
<span class="nc" id="L1562">        throw new InvalidProtocolBufferException(&quot;Not an int32 value: &quot; + json);</span>
      }
    }

    private long parseInt64(JsonElement json) throws InvalidProtocolBufferException {
      try {
<span class="fc" id="L1568">        return Long.parseLong(json.getAsString());</span>
<span class="fc" id="L1569">      } catch (Exception e) {</span>
        // Fall through.
      }
      // JSON doesn't distinguish between integer values and floating point values so &quot;1&quot; and
      // &quot;1.000&quot; are treated as equal in JSON. For this reason we accept floating point values for
      // integer fields as well as long as it actually is an integer (i.e., round(value) == value).
      try {
<span class="fc" id="L1576">        BigDecimal value = new BigDecimal(json.getAsString());</span>
<span class="fc" id="L1577">        return value.longValueExact();</span>
<span class="nc" id="L1578">      } catch (Exception e) {</span>
<span class="nc" id="L1579">        throw new InvalidProtocolBufferException(&quot;Not an int32 value: &quot; + json);</span>
      }
    }

    private int parseUint32(JsonElement json) throws InvalidProtocolBufferException {
      try {
<span class="nc" id="L1585">        long result = Long.parseLong(json.getAsString());</span>
<span class="nc bnc" id="L1586" title="All 4 branches missed.">        if (result &lt; 0 || result &gt; 0xFFFFFFFFL) {</span>
<span class="nc" id="L1587">          throw new InvalidProtocolBufferException(&quot;Out of range uint32 value: &quot; + json);</span>
        }
<span class="nc" id="L1589">        return (int) result;</span>
<span class="nc" id="L1590">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L1591">        throw e;</span>
<span class="nc" id="L1592">      } catch (Exception e) {</span>
        // Fall through.
      }
      // JSON doesn't distinguish between integer values and floating point values so &quot;1&quot; and
      // &quot;1.000&quot; are treated as equal in JSON. For this reason we accept floating point values for
      // integer fields as well as long as it actually is an integer (i.e., round(value) == value).
      try {
<span class="nc" id="L1599">        BigDecimal decimalValue = new BigDecimal(json.getAsString());</span>
<span class="nc" id="L1600">        BigInteger value = decimalValue.toBigIntegerExact();</span>
<span class="nc bnc" id="L1601" title="All 4 branches missed.">        if (value.signum() &lt; 0 || value.compareTo(new BigInteger(&quot;FFFFFFFF&quot;, 16)) &gt; 0) {</span>
<span class="nc" id="L1602">          throw new InvalidProtocolBufferException(&quot;Out of range uint32 value: &quot; + json);</span>
        }
<span class="nc" id="L1604">        return value.intValue();</span>
<span class="nc" id="L1605">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L1606">        throw e;</span>
<span class="nc" id="L1607">      } catch (Exception e) {</span>
<span class="nc" id="L1608">        throw new InvalidProtocolBufferException(&quot;Not an uint32 value: &quot; + json);</span>
      }
    }

<span class="fc" id="L1612">    private static final BigInteger MAX_UINT64 = new BigInteger(&quot;FFFFFFFFFFFFFFFF&quot;, 16);</span>

    private long parseUint64(JsonElement json) throws InvalidProtocolBufferException {
      try {
<span class="nc" id="L1616">        BigDecimal decimalValue = new BigDecimal(json.getAsString());</span>
<span class="nc" id="L1617">        BigInteger value = decimalValue.toBigIntegerExact();</span>
<span class="nc bnc" id="L1618" title="All 4 branches missed.">        if (value.compareTo(BigInteger.ZERO) &lt; 0 || value.compareTo(MAX_UINT64) &gt; 0) {</span>
<span class="nc" id="L1619">          throw new InvalidProtocolBufferException(&quot;Out of range uint64 value: &quot; + json);</span>
        }
<span class="nc" id="L1621">        return value.longValue();</span>
<span class="nc" id="L1622">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L1623">        throw e;</span>
<span class="nc" id="L1624">      } catch (Exception e) {</span>
<span class="nc" id="L1625">        throw new InvalidProtocolBufferException(&quot;Not an uint64 value: &quot; + json);</span>
      }
    }

    private boolean parseBool(JsonElement json) throws InvalidProtocolBufferException {
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">      if (json.getAsString().equals(&quot;true&quot;)) {</span>
<span class="fc" id="L1631">        return true;</span>
      }
<span class="nc bnc" id="L1633" title="All 2 branches missed.">      if (json.getAsString().equals(&quot;false&quot;)) {</span>
<span class="nc" id="L1634">        return false;</span>
      }
<span class="nc" id="L1636">      throw new InvalidProtocolBufferException(&quot;Invalid bool value: &quot; + json);</span>
    }

    private static final double EPSILON = 1e-6;

    private float parseFloat(JsonElement json) throws InvalidProtocolBufferException {
<span class="nc bnc" id="L1642" title="All 2 branches missed.">      if (json.getAsString().equals(&quot;NaN&quot;)) {</span>
<span class="nc" id="L1643">        return Float.NaN;</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">      } else if (json.getAsString().equals(&quot;Infinity&quot;)) {</span>
<span class="nc" id="L1645">        return Float.POSITIVE_INFINITY;</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">      } else if (json.getAsString().equals(&quot;-Infinity&quot;)) {</span>
<span class="nc" id="L1647">        return Float.NEGATIVE_INFINITY;</span>
      }
      try {
        // We don't use Float.parseFloat() here because that function simply
        // accepts all double values. Here we parse the value into a Double
        // and do explicit range check on it.
<span class="nc" id="L1653">        double value = Double.parseDouble(json.getAsString());</span>
        // When a float value is printed, the printed value might be a little
        // larger or smaller due to precision loss. Here we need to add a bit
        // of tolerance when checking whether the float value is in range.
<span class="nc bnc" id="L1657" title="All 4 branches missed.">        if (value &gt; Float.MAX_VALUE * (1.0 + EPSILON)</span>
            || value &lt; -Float.MAX_VALUE * (1.0 + EPSILON)) {
<span class="nc" id="L1659">          throw new InvalidProtocolBufferException(&quot;Out of range float value: &quot; + json);</span>
        }
<span class="nc" id="L1661">        return (float) value;</span>
<span class="nc" id="L1662">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L1663">        throw e;</span>
<span class="nc" id="L1664">      } catch (Exception e) {</span>
<span class="nc" id="L1665">        throw new InvalidProtocolBufferException(&quot;Not a float value: &quot; + json);</span>
      }
    }

<span class="fc" id="L1669">    private static final BigDecimal MORE_THAN_ONE = new BigDecimal(String.valueOf(1.0 + EPSILON));</span>
    // When a float value is printed, the printed value might be a little
    // larger or smaller due to precision loss. Here we need to add a bit
    // of tolerance when checking whether the float value is in range.
<span class="fc" id="L1673">    private static final BigDecimal MAX_DOUBLE =</span>
<span class="fc" id="L1674">        new BigDecimal(String.valueOf(Double.MAX_VALUE)).multiply(MORE_THAN_ONE);</span>
<span class="fc" id="L1675">    private static final BigDecimal MIN_DOUBLE =</span>
<span class="fc" id="L1676">        new BigDecimal(String.valueOf(-Double.MAX_VALUE)).multiply(MORE_THAN_ONE);</span>

    private double parseDouble(JsonElement json) throws InvalidProtocolBufferException {
<span class="nc bnc" id="L1679" title="All 2 branches missed.">      if (json.getAsString().equals(&quot;NaN&quot;)) {</span>
<span class="nc" id="L1680">        return Double.NaN;</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">      } else if (json.getAsString().equals(&quot;Infinity&quot;)) {</span>
<span class="nc" id="L1682">        return Double.POSITIVE_INFINITY;</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">      } else if (json.getAsString().equals(&quot;-Infinity&quot;)) {</span>
<span class="nc" id="L1684">        return Double.NEGATIVE_INFINITY;</span>
      }
      try {
        // We don't use Double.parseDouble() here because that function simply
        // accepts all values. Here we parse the value into a BigDecimal and do
        // explicit range check on it.
<span class="nc" id="L1690">        BigDecimal value = new BigDecimal(json.getAsString());</span>
<span class="nc bnc" id="L1691" title="All 4 branches missed.">        if (value.compareTo(MAX_DOUBLE) &gt; 0 || value.compareTo(MIN_DOUBLE) &lt; 0) {</span>
<span class="nc" id="L1692">          throw new InvalidProtocolBufferException(&quot;Out of range double value: &quot; + json);</span>
        }
<span class="nc" id="L1694">        return value.doubleValue();</span>
<span class="nc" id="L1695">      } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L1696">        throw e;</span>
<span class="nc" id="L1697">      } catch (Exception e) {</span>
<span class="nc" id="L1698">        throw new InvalidProtocolBufferException(&quot;Not an double value: &quot; + json);</span>
      }
    }

    private String parseString(JsonElement json) {
<span class="fc" id="L1703">      return json.getAsString();</span>
    }

    private ByteString parseBytes(JsonElement json) throws InvalidProtocolBufferException {
<span class="nc" id="L1707">      return ByteString.copyFrom(BaseEncoding.base64().decode(json.getAsString()));</span>
    }

    private EnumValueDescriptor parseEnum(EnumDescriptor enumDescriptor, JsonElement json)
        throws InvalidProtocolBufferException {
<span class="fc" id="L1712">      String value = json.getAsString();</span>
<span class="fc" id="L1713">      EnumValueDescriptor result = enumDescriptor.findValueByName(value);</span>
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">      if (result == null) {</span>
        // Try to interpret the value as a number.
        try {
<span class="nc" id="L1717">          int numericValue = parseInt32(json);</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">          if (enumDescriptor.getFile().getSyntax() == FileDescriptor.Syntax.PROTO3) {</span>
<span class="nc" id="L1719">            result = enumDescriptor.findValueByNumberCreatingIfUnknown(numericValue);</span>
          } else {
<span class="nc" id="L1721">            result = enumDescriptor.findValueByNumber(numericValue);</span>
          }
<span class="nc" id="L1723">        } catch (InvalidProtocolBufferException e) {</span>
          // Fall through. This exception is about invalid int32 value we get from parseInt32() but
          // that's not the exception we want the user to see. Since result == null, we will throw
          // an exception later.
<span class="nc" id="L1727">        }</span>

<span class="nc bnc" id="L1729" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L1730">          throw new InvalidProtocolBufferException(</span>
<span class="nc" id="L1731">              &quot;Invalid enum value: &quot; + value + &quot; for enum type: &quot; + enumDescriptor.getFullName());</span>
        }
      }
<span class="fc" id="L1734">      return result;</span>
    }

    private Object parseFieldValue(FieldDescriptor field, JsonElement json, Message.Builder builder)
        throws InvalidProtocolBufferException {
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">      if (json instanceof JsonNull) {</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">            &amp;&amp; field.getMessageType().getFullName().equals(Value.getDescriptor().getFullName())) {</span>
          // For every other type, &quot;null&quot; means absence, but for the special
          // Value message, it means the &quot;null_value&quot; field has been set.
<span class="nc" id="L1744">          Value value = Value.newBuilder().setNullValueValue(0).build();</span>
<span class="nc" id="L1745">          return builder.newBuilderForField(field).mergeFrom(value.toByteString()).build();</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        } else if (field.getJavaType() == FieldDescriptor.JavaType.ENUM</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            &amp;&amp; field.getEnumType().getFullName().equals(NullValue.getDescriptor().getFullName())) {</span>
          // If the type of the field is a NullValue, then the value should be explicitly set.
<span class="nc" id="L1749">          return field.getEnumType().findValueByNumber(0);</span>
        }
<span class="nc" id="L1751">        return null;</span>
      }
<span class="pc bpc" id="L1753" title="6 of 12 branches missed.">      switch (field.getType()) {</span>
        case INT32:
        case SINT32:
        case SFIXED32:
<span class="fc" id="L1757">          return parseInt32(json);</span>

        case INT64:
        case SINT64:
        case SFIXED64:
<span class="fc" id="L1762">          return parseInt64(json);</span>

        case BOOL:
<span class="fc" id="L1765">          return parseBool(json);</span>

        case FLOAT:
<span class="nc" id="L1768">          return parseFloat(json);</span>

        case DOUBLE:
<span class="nc" id="L1771">          return parseDouble(json);</span>

        case UINT32:
        case FIXED32:
<span class="nc" id="L1775">          return parseUint32(json);</span>

        case UINT64:
        case FIXED64:
<span class="nc" id="L1779">          return parseUint64(json);</span>

        case STRING:
<span class="fc" id="L1782">          return parseString(json);</span>

        case BYTES:
<span class="nc" id="L1785">          return parseBytes(json);</span>

        case ENUM:
<span class="fc" id="L1788">          return parseEnum(field.getEnumType(), json);</span>

        case MESSAGE:
        case GROUP:
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">          if (currentDepth &gt;= recursionLimit) {</span>
<span class="nc" id="L1793">            throw new InvalidProtocolBufferException(&quot;Hit recursion limit.&quot;);</span>
          }
<span class="fc" id="L1795">          ++currentDepth;</span>
<span class="fc" id="L1796">          Message.Builder subBuilder = builder.newBuilderForField(field);</span>
<span class="fc" id="L1797">          merge(json, subBuilder);</span>
<span class="fc" id="L1798">          --currentDepth;</span>
<span class="fc" id="L1799">          return subBuilder.build();</span>

        default:
<span class="nc" id="L1802">          throw new InvalidProtocolBufferException(&quot;Invalid field type: &quot; + field.getType());</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>