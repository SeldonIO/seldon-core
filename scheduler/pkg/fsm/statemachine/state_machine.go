/*
Copyright (c) 2024 Seldon Technologies Ltd.

Use of this software is governed BY
(1) the license included in the LICENSE file or
(2) if the license included in the LICENSE file is the Business Source License 1.1,
the Change License after the Change Date as each is defined in accordance with the LICENSE file.
*/

package statemachine

import (
	pb "github.com/seldonio/seldon-core/apis/go/v2/mlops/scheduler"
)

type StateMachine struct {
}

func NewStateMachine() *StateMachine {
	return &StateMachine{}
}

type FSM interface {
	ApplyLoadModel(current ClusterState, request *pb.LoadModelRequest) (StateTransitionResult, []DomainEvent)
}

type StateTransitionResult struct {
	Model       map[string]*pb.ModelSnapshot
	Pipelines   map[string]*pb.PipelineSnapshot
	Experiments map[string]*pb.ExperimentSnapshot
}

// DomainEvent todo: further define the domain events
// DomainEvent represents a business-level event generated by state transitions
type DomainEvent interface {
	EventType() string
}

// ApplyLoadModel applies business logic for loading a model
// Pure function: same inputs â†’ same outputs
func (sm *StateMachine) ApplyLoadModel(
	current ClusterState,
	request *pb.LoadModelRequest,
) (StateTransitionResult, []DomainEvent) {
	modelName := request.GetModel().GetMeta().GetName()

	// calculate the future model state
	futureModelState := current.generateModelSnapshot(request.GetModel())

	// calculate the future pipelines states
	//todo:

	// calculate the future experiment states
	//todo:

	// generate events from state differences {current_cluster_state} + future state = events

}
