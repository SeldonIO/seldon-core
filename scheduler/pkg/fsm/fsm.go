/*
Copyright (c) 2024 Seldon Technologies Ltd.

Use of this software is governed BY
(1) the license included in the LICENSE file or
(2) if the license included in the LICENSE file is the Business Source License 1.1,
the Change License after the Change Date as each is defined in accordance with the LICENSE file.
*/

package fsm

import (
	"context"
	"fmt"
)

// todo: we could do our tradicional locking too but for this to probably work we would need a manager to do the updates
// todo: the manager would then lock the entire Handle of an event and do its processing, could become a little bit of a problem when having many status updates from Agents
// KVStore interface for state persistence with optimistic locking
type KVStore interface {
	// Get retrieves value and current version
	Get(ctx context.Context, key string) (value []byte, version int64, err error)
	// Set without version check (for initial writes)
	Set(ctx context.Context, key string, value []byte) (int64, error)
	Delete(ctx context.Context, key string) error
}

// Event represents an incoming event to the FSM
type Event interface {
	Type() EventType
	Marshal() ([]byte, error)
}

type EventType string

const (
	EventTypeLoadModel   EventType = "LoadModel"
	EventTypeUnloadModel EventType = "UnloadModel"
)

// OutputEvent represents events generated by the FSM for downstream consumers
type OutputEvent interface {
	Type() string
}

// Fsm is the finite state machine that processes events
type Fsm struct {
	name     string
	store    KVStore
	handlers map[EventType]Handler
}

type Handler interface {
	Handle(ctx context.Context, ev Event) ([]OutputEvent, error)
}

func NewFSM(name string, store KVStore) *Fsm {
	fsm := &Fsm{
		name:     name,
		store:    store,
		handlers: make(map[EventType]Handler),
	}

	// Register default handlers
	fsm.RegisterHandler(EventTypeLoadModel, NewLoadModelEventHandler(store))

	return fsm
}

func (f *Fsm) RegisterHandler(eventType EventType, handler Handler) {
	f.handlers[eventType] = handler
}

// Start recovers uncommitted events and begins processing
func (f *Fsm) Start(ctx context.Context) error {
	// Replay uncommitted events on startup (crash recovery)
	uncommitted, err := f.log.GetUncommitted(ctx)
	if err != nil {
		return fmt.Errorf("failed to get uncommitted events: %w", err)
	}

	for _, event := range uncommitted {
		if _, err := f.Apply(ctx, event); err != nil {
			return fmt.Errorf("failed to replay event: %w", err)
		}
	}

	return nil
}

// Apply processes an event through the FSM
// 1. Appends to log (uncommitted)
// 2. Applies business logic and updates KVStore
// 3. Generates output events
// 4. Marks as committed
func (f *Fsm) Apply(ctx context.Context, event Event) ([]OutputEvent, error) {
	// 1. Write to log (for crash recovery)
	seqNum, err := f.log.Append(ctx, event)
	if err != nil {
		return nil, fmt.Errorf("failed to append to log: %w", err)
	}

	// 2. Get handler for this event type
	handler, exists := f.handlers[event.Type()]
	if !exists {
		return nil, fmt.Errorf("no handler registered for event type: %s", event.Type())
	}

	// 3. Process event and update KVStore
	outputEvents, err := handler.Handle(ctx, event)
	if err != nil {
		return nil, fmt.Errorf("handler failed: %w", err)
	}

	// 4. Mark as committed in log
	if err := f.log.MarkCommitted(ctx, seqNum); err != nil {
		return nil, fmt.Errorf("failed to mark committed: %w", err)
	}

	return outputEvents, nil
}
