/*
Copyright (c) 2024 Seldon Technologies Ltd.

Use of this software is governed BY
(1) the license included in the LICENSE file or
(2) if the license included in the LICENSE file is the Business Source License 1.1,
the Change License after the Change Date as each is defined in accordance with the LICENSE file.
*/

package fsm

import (
	"context"
	"fmt"

	"github.com/seldonio/seldon-core/scheduler/v2/pkg/fsm/storage"
)

// Event represents an incoming event to the FSM
type Event interface {
	Type() EventType
	Marshal() ([]byte, error)
}

type EventType string

const (
	EventTypeLoadModel   EventType = "LoadModel"
	EventTypeUnloadModel EventType = "UnloadModel"
)

// OutputEvent represents events generated by the FSM for downstream consumers
type OutputEvent interface {
	Type() string
}

// Fsm is the finite state machine that processes events
type Fsm struct {
	name     string
	store    storage.ClusterManager
	handlers map[EventType]Handler
}

type Handler interface {
	Handle(ctx context.Context, ev Event) ([]OutputEvent, error)
}

func NewFSM(name string, store storage.ClusterManager) *Fsm {
	fsm := &Fsm{
		name:     name,
		store:    store,
		handlers: make(map[EventType]Handler),
	}

	// Register default handlers
	fsm.RegisterHandler(EventTypeLoadModel, NewLoadModelEventHandler(store))

	return fsm
}

func (f *Fsm) RegisterHandler(eventType EventType, handler Handler) {
	f.handlers[eventType] = handler
}

// Apply processes an event through the FSM
// 1. Applies business logic and updates KVStore
// 2. Generates output events
func (f *Fsm) Apply(ctx context.Context, event Event) ([]OutputEvent, error) {

	// 2. Get handler for this event type
	handler, exists := f.handlers[event.Type()]
	if !exists {
		return nil, fmt.Errorf("no handler registered for event type: %s", event.Type())
	}

	// 3. Process event and update KVStore
	outputEvents, err := handler.Handle(ctx, event)
	if err != nil {
		return nil, fmt.Errorf("handler failed: %w", err)
	}

	return outputEvents, nil
}
