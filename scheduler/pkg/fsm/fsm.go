package fsm

import (
	"context"
	"fmt"
)

// todo: we could do our tradicional locking too but for this to probably work we would need a manager to do the updates
// todo: the manager would then lock the entire Handle of an event and do its processing, could become a little bit of a problem when having many status updates from Agents
// KVStore interface for state persistence with optimistic locking
type KVStore interface {
	// Get retrieves value and current version
	Get(ctx context.Context, key string) (value []byte, version int64, err error)
	// Set with version check (returns ErrVersionConflict if version doesn't match)
	SetWithVersion(ctx context.Context, key string, value []byte, expectedVersion int64) (newVersion int64, err error)
	// Set without version check (for initial writes)
	Set(ctx context.Context, key string, value []byte) (int64, error)
	Delete(ctx context.Context, key string) error
}

// ErrVersionConflict indicates an optimistic locking conflict
var ErrVersionConflict = fmt.Errorf("version conflict")

// EventLog interface for append-only event storage
type EventLog interface {
	// Append writes an event to the log and returns its sequence number
	Append(ctx context.Context, event Event) (int64, error)
	// MarkCommitted marks an event as successfully processed
	MarkCommitted(ctx context.Context, seqNum int64) error
	// GetUncommitted returns all uncommitted events (for crash recovery)
	GetUncommitted(ctx context.Context) ([]Event, error)
}

// Event represents an incoming event to the FSM
type Event interface {
	Type() EventType
	Marshal() ([]byte, error)
}

type EventType string

const (
	EventTypeLoadModel   EventType = "LoadModel"
	EventTypeUnloadModel EventType = "UnloadModel"
)

// OutputEvent represents events generated by the FSM for downstream consumers
type OutputEvent interface {
	Type() string
}

// Fsm is the finite state machine that processes events
type Fsm struct {
	name     string
	store    KVStore
	log      EventLog
	handlers map[EventType]Handler
}

type Handler interface {
	Handle(ctx context.Context, ev Event) ([]OutputEvent, error)
}

func NewFSM(name string, store KVStore, log EventLog) *Fsm {
	fsm := &Fsm{
		name:     name,
		store:    store,
		log:      log,
		handlers: make(map[EventType]Handler),
	}

	// Register default handlers
	fsm.RegisterHandler(EventTypeLoadModel, NewLoadModelEventHandler(store))

	return fsm
}

func (f *Fsm) RegisterHandler(eventType EventType, handler Handler) {
	f.handlers[eventType] = handler
}

// Start recovers uncommitted events and begins processing
func (f *Fsm) Start(ctx context.Context) error {
	// Replay uncommitted events on startup (crash recovery)
	uncommitted, err := f.log.GetUncommitted(ctx)
	if err != nil {
		return fmt.Errorf("failed to get uncommitted events: %w", err)
	}

	for _, event := range uncommitted {
		if _, err := f.Apply(ctx, event); err != nil {
			return fmt.Errorf("failed to replay event: %w", err)
		}
	}

	return nil
}

// Apply processes an event through the FSM
// 1. Appends to log (uncommitted)
// 2. Applies business logic and updates KVStore
// 3. Generates output events
// 4. Marks as committed
func (f *Fsm) Apply(ctx context.Context, event Event) ([]OutputEvent, error) {
	// 1. Write to log (for crash recovery)
	seqNum, err := f.log.Append(ctx, event)
	if err != nil {
		return nil, fmt.Errorf("failed to append to log: %w", err)
	}

	// 2. Get handler for this event type
	handler, exists := f.handlers[event.Type()]
	if !exists {
		return nil, fmt.Errorf("no handler registered for event type: %s", event.Type())
	}

	// 3. Process event and update KVStore
	outputEvents, err := handler.Handle(ctx, event)
	if err != nil {
		return nil, fmt.Errorf("handler failed: %w", err)
	}

	// 4. Mark as committed in log
	if err := f.log.MarkCommitted(ctx, seqNum); err != nil {
		return nil, fmt.Errorf("failed to mark committed: %w", err)
	}

	return outputEvents, nil
}
