// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/seldonio/seldon-core/apis/go/v2/mlops/scheduler (interfaces: SchedulerClient)
//
// Generated by this command:
//
//	mockgen -package=mocks -destination=pkg/kafka/pipeline/mocks/mock_scheduler_client.go github.com/seldonio/seldon-core/apis/go/v2/mlops/scheduler SchedulerClient
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	chainer "github.com/seldonio/seldon-core/apis/go/v2/mlops/chainer"
	scheduler "github.com/seldonio/seldon-core/apis/go/v2/mlops/scheduler"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockSchedulerClient is a mock of SchedulerClient interface.
type MockSchedulerClient struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerClientMockRecorder
}

// MockSchedulerClientMockRecorder is the mock recorder for MockSchedulerClient.
type MockSchedulerClientMockRecorder struct {
	mock *MockSchedulerClient
}

// NewMockSchedulerClient creates a new mock instance.
func NewMockSchedulerClient(ctrl *gomock.Controller) *MockSchedulerClient {
	mock := &MockSchedulerClient{ctrl: ctrl}
	mock.recorder = &MockSchedulerClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSchedulerClient) EXPECT() *MockSchedulerClientMockRecorder {
	return m.recorder
}

// ExperimentStatus mocks base method.
func (m *MockSchedulerClient) ExperimentStatus(arg0 context.Context, arg1 *scheduler.ExperimentStatusRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_ExperimentStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExperimentStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_ExperimentStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExperimentStatus indicates an expected call of ExperimentStatus.
func (mr *MockSchedulerClientMockRecorder) ExperimentStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExperimentStatus", reflect.TypeOf((*MockSchedulerClient)(nil).ExperimentStatus), varargs...)
}

// LoadModel mocks base method.
func (m *MockSchedulerClient) LoadModel(arg0 context.Context, arg1 *scheduler.LoadModelRequest, arg2 ...grpc.CallOption) (*scheduler.LoadModelResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadModel", varargs...)
	ret0, _ := ret[0].(*scheduler.LoadModelResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadModel indicates an expected call of LoadModel.
func (mr *MockSchedulerClientMockRecorder) LoadModel(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadModel", reflect.TypeOf((*MockSchedulerClient)(nil).LoadModel), varargs...)
}

// LoadPipeline mocks base method.
func (m *MockSchedulerClient) LoadPipeline(arg0 context.Context, arg1 *scheduler.LoadPipelineRequest, arg2 ...grpc.CallOption) (*scheduler.LoadPipelineResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadPipeline", varargs...)
	ret0, _ := ret[0].(*scheduler.LoadPipelineResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadPipeline indicates an expected call of LoadPipeline.
func (mr *MockSchedulerClientMockRecorder) LoadPipeline(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadPipeline", reflect.TypeOf((*MockSchedulerClient)(nil).LoadPipeline), varargs...)
}

// ModelStatus mocks base method.
func (m *MockSchedulerClient) ModelStatus(arg0 context.Context, arg1 *scheduler.ModelStatusRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_ModelStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ModelStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_ModelStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelStatus indicates an expected call of ModelStatus.
func (mr *MockSchedulerClientMockRecorder) ModelStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelStatus", reflect.TypeOf((*MockSchedulerClient)(nil).ModelStatus), varargs...)
}

// PipelineStatus mocks base method.
func (m *MockSchedulerClient) PipelineStatus(arg0 context.Context, arg1 *scheduler.PipelineStatusRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_PipelineStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PipelineStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_PipelineStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PipelineStatus indicates an expected call of PipelineStatus.
func (mr *MockSchedulerClientMockRecorder) PipelineStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipelineStatus", reflect.TypeOf((*MockSchedulerClient)(nil).PipelineStatus), varargs...)
}

// PipelineStatusEvent mocks base method.
func (m *MockSchedulerClient) PipelineStatusEvent(arg0 context.Context, arg1 *chainer.PipelineUpdateStatusMessage, arg2 ...grpc.CallOption) (*chainer.PipelineUpdateStatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PipelineStatusEvent", varargs...)
	ret0, _ := ret[0].(*chainer.PipelineUpdateStatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PipelineStatusEvent indicates an expected call of PipelineStatusEvent.
func (mr *MockSchedulerClientMockRecorder) PipelineStatusEvent(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipelineStatusEvent", reflect.TypeOf((*MockSchedulerClient)(nil).PipelineStatusEvent), varargs...)
}

// SchedulerStatus mocks base method.
func (m *MockSchedulerClient) SchedulerStatus(arg0 context.Context, arg1 *scheduler.SchedulerStatusRequest, arg2 ...grpc.CallOption) (*scheduler.SchedulerStatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SchedulerStatus", varargs...)
	ret0, _ := ret[0].(*scheduler.SchedulerStatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SchedulerStatus indicates an expected call of SchedulerStatus.
func (mr *MockSchedulerClientMockRecorder) SchedulerStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulerStatus", reflect.TypeOf((*MockSchedulerClient)(nil).SchedulerStatus), varargs...)
}

// ServerNotify mocks base method.
func (m *MockSchedulerClient) ServerNotify(arg0 context.Context, arg1 *scheduler.ServerNotifyRequest, arg2 ...grpc.CallOption) (*scheduler.ServerNotifyResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ServerNotify", varargs...)
	ret0, _ := ret[0].(*scheduler.ServerNotifyResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ServerNotify indicates an expected call of ServerNotify.
func (mr *MockSchedulerClientMockRecorder) ServerNotify(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServerNotify", reflect.TypeOf((*MockSchedulerClient)(nil).ServerNotify), varargs...)
}

// ServerStatus mocks base method.
func (m *MockSchedulerClient) ServerStatus(arg0 context.Context, arg1 *scheduler.ServerStatusRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_ServerStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ServerStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_ServerStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ServerStatus indicates an expected call of ServerStatus.
func (mr *MockSchedulerClientMockRecorder) ServerStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServerStatus", reflect.TypeOf((*MockSchedulerClient)(nil).ServerStatus), varargs...)
}

// StartExperiment mocks base method.
func (m *MockSchedulerClient) StartExperiment(arg0 context.Context, arg1 *scheduler.StartExperimentRequest, arg2 ...grpc.CallOption) (*scheduler.StartExperimentResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartExperiment", varargs...)
	ret0, _ := ret[0].(*scheduler.StartExperimentResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartExperiment indicates an expected call of StartExperiment.
func (mr *MockSchedulerClientMockRecorder) StartExperiment(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartExperiment", reflect.TypeOf((*MockSchedulerClient)(nil).StartExperiment), varargs...)
}

// StopExperiment mocks base method.
func (m *MockSchedulerClient) StopExperiment(arg0 context.Context, arg1 *scheduler.StopExperimentRequest, arg2 ...grpc.CallOption) (*scheduler.StopExperimentResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StopExperiment", varargs...)
	ret0, _ := ret[0].(*scheduler.StopExperimentResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StopExperiment indicates an expected call of StopExperiment.
func (mr *MockSchedulerClientMockRecorder) StopExperiment(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopExperiment", reflect.TypeOf((*MockSchedulerClient)(nil).StopExperiment), varargs...)
}

// SubscribeControlPlane mocks base method.
func (m *MockSchedulerClient) SubscribeControlPlane(arg0 context.Context, arg1 *scheduler.ControlPlaneSubscriptionRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_SubscribeControlPlaneClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeControlPlane", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_SubscribeControlPlaneClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeControlPlane indicates an expected call of SubscribeControlPlane.
func (mr *MockSchedulerClientMockRecorder) SubscribeControlPlane(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeControlPlane", reflect.TypeOf((*MockSchedulerClient)(nil).SubscribeControlPlane), varargs...)
}

// SubscribeExperimentStatus mocks base method.
func (m *MockSchedulerClient) SubscribeExperimentStatus(arg0 context.Context, arg1 *scheduler.ExperimentSubscriptionRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_SubscribeExperimentStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeExperimentStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_SubscribeExperimentStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeExperimentStatus indicates an expected call of SubscribeExperimentStatus.
func (mr *MockSchedulerClientMockRecorder) SubscribeExperimentStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeExperimentStatus", reflect.TypeOf((*MockSchedulerClient)(nil).SubscribeExperimentStatus), varargs...)
}

// SubscribeModelStatus mocks base method.
func (m *MockSchedulerClient) SubscribeModelStatus(arg0 context.Context, arg1 *scheduler.ModelSubscriptionRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_SubscribeModelStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeModelStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_SubscribeModelStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeModelStatus indicates an expected call of SubscribeModelStatus.
func (mr *MockSchedulerClientMockRecorder) SubscribeModelStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeModelStatus", reflect.TypeOf((*MockSchedulerClient)(nil).SubscribeModelStatus), varargs...)
}

// SubscribePipelineStatus mocks base method.
func (m *MockSchedulerClient) SubscribePipelineStatus(arg0 context.Context, arg1 *scheduler.PipelineSubscriptionRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_SubscribePipelineStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribePipelineStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_SubscribePipelineStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribePipelineStatus indicates an expected call of SubscribePipelineStatus.
func (mr *MockSchedulerClientMockRecorder) SubscribePipelineStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribePipelineStatus", reflect.TypeOf((*MockSchedulerClient)(nil).SubscribePipelineStatus), varargs...)
}

// SubscribeServerStatus mocks base method.
func (m *MockSchedulerClient) SubscribeServerStatus(arg0 context.Context, arg1 *scheduler.ServerSubscriptionRequest, arg2 ...grpc.CallOption) (scheduler.Scheduler_SubscribeServerStatusClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeServerStatus", varargs...)
	ret0, _ := ret[0].(scheduler.Scheduler_SubscribeServerStatusClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeServerStatus indicates an expected call of SubscribeServerStatus.
func (mr *MockSchedulerClientMockRecorder) SubscribeServerStatus(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeServerStatus", reflect.TypeOf((*MockSchedulerClient)(nil).SubscribeServerStatus), varargs...)
}

// UnloadModel mocks base method.
func (m *MockSchedulerClient) UnloadModel(arg0 context.Context, arg1 *scheduler.UnloadModelRequest, arg2 ...grpc.CallOption) (*scheduler.UnloadModelResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnloadModel", varargs...)
	ret0, _ := ret[0].(*scheduler.UnloadModelResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnloadModel indicates an expected call of UnloadModel.
func (mr *MockSchedulerClientMockRecorder) UnloadModel(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnloadModel", reflect.TypeOf((*MockSchedulerClient)(nil).UnloadModel), varargs...)
}

// UnloadPipeline mocks base method.
func (m *MockSchedulerClient) UnloadPipeline(arg0 context.Context, arg1 *scheduler.UnloadPipelineRequest, arg2 ...grpc.CallOption) (*scheduler.UnloadPipelineResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnloadPipeline", varargs...)
	ret0, _ := ret[0].(*scheduler.UnloadPipelineResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnloadPipeline indicates an expected call of UnloadPipeline.
func (mr *MockSchedulerClientMockRecorder) UnloadPipeline(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnloadPipeline", reflect.TypeOf((*MockSchedulerClient)(nil).UnloadPipeline), varargs...)
}
